import{S as V,i as P,s as q,k as U,q as _,a as O,l as D,m as R,r as d,c as I,h as f,b as w,G as k,Q as y,u as H,B as L,D as K,al as at,w as x,x as T,y as C,f as G,t as A,z as E,am as $t,K as ct,an as j,M as F,N as ft,O as rt,P as ot}from"./index-58af1356.js";import{M as ut,P as z}from"./mdsvex-layout-notes-a943bafe.js";import{w as it}from"./index-be13bd0b.js";import{S as st}from"./ShowMany-e03b9690.js";import{S}from"./Strong-d8efce91.js";function mt(a){let t,e,n,l,r,$,u,p,o,c,h;return{c(){t=U("div"),e=_("Grandchildren: "),n=_(a[0]),l=O(),r=U("button"),$=_("+"),u=O(),p=U("button"),o=_("-")},l(g){t=D(g,"DIV",{});var m=R(t);e=d(m,"Grandchildren: "),n=d(m,a[0]),l=I(m),r=D(m,"BUTTON",{});var B=R(r);$=d(B,"+"),B.forEach(f),u=I(m),p=D(m,"BUTTON",{});var i=R(p);o=d(i,"-"),i.forEach(f),m.forEach(f)},m(g,m){w(g,t,m),k(t,e),k(t,n),k(t,l),k(t,r),k(r,$),k(t,u),k(t,p),k(p,o),c||(h=[y(r,"click",a[1]),y(p,"click",a[2])],c=!0)},p(g,[m]){m&1&&H(n,g[0])},i:L,o:L,d(g){g&&f(t),c=!1,K(h)}}}function pt(a,t,e){let n=at("value");return[n,()=>e(0,n++,n),()=>e(0,n--,n)]}class _t extends V{constructor(t){super(),P(this,t,pt,mt,q,{})}}function dt(a){let t,e;return t=new _t({}),{c(){x(t.$$.fragment)},l(n){T(t.$$.fragment,n)},m(n,l){C(t,n,l),e=!0},p:L,i(n){e||(G(t.$$.fragment,n),e=!0)},o(n){A(t.$$.fragment,n),e=!1},d(n){E(t,n)}}}class wt extends V{constructor(t){super(),P(this,t,null,dt,q,{})}}function gt(a){let t,e,n,l,r,$,u,p,o,c,h,g,m,B;return h=new wt({}),{c(){t=U("div"),e=_("App: "),n=_(a[0]),l=O(),r=U("button"),$=_("+"),u=O(),p=U("button"),o=_("-"),c=O(),x(h.$$.fragment)},l(i){t=D(i,"DIV",{});var v=R(t);e=d(v,"App: "),n=d(v,a[0]),l=I(v),r=D(v,"BUTTON",{});var N=R(r);$=d(N,"+"),N.forEach(f),u=I(v),p=D(v,"BUTTON",{});var M=R(p);o=d(M,"-"),M.forEach(f),v.forEach(f),c=I(i),T(h.$$.fragment,i)},m(i,v){w(i,t,v),k(t,e),k(t,n),k(t,l),k(t,r),k(r,$),k(t,u),k(t,p),k(p,o),w(i,c,v),C(h,i,v),g=!0,m||(B=[y(r,"click",a[1]),y(p,"click",a[2])],m=!0)},p(i,[v]){(!g||v&1)&&H(n,i[0])},i(i){g||(G(h.$$.fragment,i),g=!0)},o(i){A(h.$$.fragment,i),g=!1},d(i){i&&f(t),i&&f(c),E(h,i),m=!1,K(B)}}}function ht(a,t,e){let n=10;return $t("value",n),[n,()=>e(0,n++,n),()=>e(0,n--,n)]}class Q extends V{constructor(t){super(),P(this,t,ht,gt,q,{})}}const vt=`<script>\r
	import Child from "./Child.svelte";\r
	import { setContext } from "svelte";\r
\r
	let count = 10;\r
\r
	setContext("value", count);\r
<\/script>\r
\r
<div>\r
	App: {count}\r
	<button on:click={() => count++}>+</button>\r
	<button on:click={() => count--}>-</button>\r
</div>\r
\r
<Child />\r
`,bt=`<script>\r
	import Grandchildren from "./Grandchildren.svelte";\r
<\/script>\r
\r
<Grandchildren />\r
`,kt=`<script>\r
	import { getContext } from "svelte";\r
\r
	let count = getContext("value");\r
<\/script>\r
\r
<div>\r
	Grandchildren: {count}\r
	<button on:click={() => count++}>+</button>\r
	<button on:click={() => count--}>-</button>\r
</div>\r
`;function xt(a){let t,e,n,l,r,$,u,p,o,c,h;return{c(){t=U("div"),e=_("Grandchildren: "),n=_(a[0]),l=O(),r=U("button"),$=_("+"),u=O(),p=U("button"),o=_("-")},l(g){t=D(g,"DIV",{});var m=R(t);e=d(m,"Grandchildren: "),n=d(m,a[0]),l=I(m),r=D(m,"BUTTON",{});var B=R(r);$=d(B,"+"),B.forEach(f),u=I(m),p=D(m,"BUTTON",{});var i=R(p);o=d(i,"-"),i.forEach(f),m.forEach(f)},m(g,m){w(g,t,m),k(t,e),k(t,n),k(t,l),k(t,r),k(r,$),k(t,u),k(t,p),k(p,o),c||(h=[y(r,"click",a[2]),y(p,"click",a[3])],c=!0)},p(g,[m]){m&1&&H(n,g[0])},i:L,o:L,d(g){g&&f(t),c=!1,K(h)}}}function Tt(a,t,e){let n,l=at("value");return ct(a,l,u=>e(0,n=u)),[n,l,()=>j(l,n++,n),()=>j(l,n--,n)]}class Ct extends V{constructor(t){super(),P(this,t,Tt,xt,q,{})}}function Gt(a){let t,e;return t=new Ct({}),{c(){x(t.$$.fragment)},l(n){T(t.$$.fragment,n)},m(n,l){C(t,n,l),e=!0},p:L,i(n){e||(G(t.$$.fragment,n),e=!0)},o(n){A(t.$$.fragment,n),e=!1},d(n){E(t,n)}}}class At extends V{constructor(t){super(),P(this,t,null,Gt,q,{})}}function Et(a){let t,e,n,l,r,$,u,p,o,c,h,g,m,B;return h=new At({}),{c(){t=U("div"),e=_("App: "),n=_(a[0]),l=O(),r=U("button"),$=_("+"),u=O(),p=U("button"),o=_("-"),c=O(),x(h.$$.fragment)},l(i){t=D(i,"DIV",{});var v=R(t);e=d(v,"App: "),n=d(v,a[0]),l=I(v),r=D(v,"BUTTON",{});var N=R(r);$=d(N,"+"),N.forEach(f),u=I(v),p=D(v,"BUTTON",{});var M=R(p);o=d(M,"-"),M.forEach(f),v.forEach(f),c=I(i),T(h.$$.fragment,i)},m(i,v){w(i,t,v),k(t,e),k(t,n),k(t,l),k(t,r),k(r,$),k(t,u),k(t,p),k(p,o),w(i,c,v),C(h,i,v),g=!0,m||(B=[y(r,"click",a[2]),y(p,"click",a[3])],m=!0)},p(i,[v]){(!g||v&1)&&H(n,i[0])},i(i){g||(G(h.$$.fragment,i),g=!0)},o(i){A(h.$$.fragment,i),g=!1},d(i){i&&f(t),i&&f(c),E(h,i),m=!1,K(B)}}}function Ot(a,t,e){let n,l=it(10);return ct(a,l,u=>e(0,n=u)),$t("value",l),[n,l,()=>j(l,n++,n),()=>j(l,n--,n)]}class Z extends V{constructor(t){super(),P(this,t,Ot,Et,q,{})}}const It=`<script>\r
	import Child2 from "./Child2.svelte";\r
  import { writable } from "svelte/store";\r
	import { setContext } from "svelte";\r
\r
	let count = writable(10);\r
\r
	setContext("value", count);\r
<\/script>\r
\r
<div>\r
	App: {$count}\r
	<button on:click={() => $count++}>+</button>\r
	<button on:click={() => $count--}>-</button>\r
</div>\r
\r
<Child2 />\r
`,Bt=`<script>\r
	import Grandchildren2 from "./Grandchildren2.svelte";\r
<\/script>\r
\r
<Grandchildren2 />\r
`,Nt=`<script>\r
	import { getContext } from "svelte";\r
\r
	let count = getContext("value");\r
<\/script>\r
\r
<div>\r
	Grandchildren: {$count}\r
	<button on:click={() => $count++}>+</button>\r
	<button on:click={() => $count--}>-</button>\r
</div>\r
`;function Ut(a){let t;return{c(){t=_("external store")},l(e){t=d(e,"external store")},m(e,n){w(e,t,n)},d(e){e&&f(t)}}}function Dt(a){let t,e,n,l;return e=new S({props:{$$slots:{default:[Ut]},$$scope:{ctx:a}}}),{c(){t=_("If we want our data to not be linked to our components in any way we could use an "),x(e.$$.fragment),n=_(", but here we want to share the data between only the main component, the children and the grandchildren.")},l(r){t=d(r,"If we want our data to not be linked to our components in any way we could use an "),T(e.$$.fragment,r),n=d(r,", but here we want to share the data between only the main component, the children and the grandchildren.")},m(r,$){w(r,t,$),C(e,r,$),w(r,n,$),l=!0},p(r,$){const u={};$&2&&(u.$$scope={dirty:$,ctx:r}),e.$set(u)},i(r){l||(G(e.$$.fragment,r),l=!0)},o(r){A(e.$$.fragment,r),l=!1},d(r){r&&f(t),E(e,r),r&&f(n)}}}function Rt(a){let t;return{c(){t=_("context")},l(e){t=d(e,"context")},m(e,n){w(e,t,n)},d(e){e&&f(t)}}}function Mt(a){let t,e,n,l;return e=new S({props:{$$slots:{default:[Rt]},$$scope:{ctx:a}}}),{c(){t=_("That's why we will use "),x(e.$$.fragment),n=_(" here.")},l(r){t=d(r,"That's why we will use "),T(e.$$.fragment,r),n=d(r," here.")},m(r,$){w(r,t,$),C(e,r,$),w(r,n,$),l=!0},p(r,$){const u={};$&2&&(u.$$scope={dirty:$,ctx:r}),e.$set(u)},i(r){l||(G(e.$$.fragment,r),l=!0)},o(r){A(e.$$.fragment,r),l=!1},d(r){r&&f(t),E(e,r),r&&f(n)}}}function St(a){let t;return{c(){t=_("key")},l(e){t=d(e,"key")},m(e,n){w(e,t,n)},d(e){e&&f(t)}}}function yt(a){let t;return{c(){t=_("value")},l(e){t=d(e,"value")},m(e,n){w(e,t,n)},d(e){e&&f(t)}}}function zt(a){let t;return{c(){t=_("component initialization")},l(e){t=d(e,"component initialization")},m(e,n){w(e,t,n)},d(e){e&&f(t)}}}function Vt(a){let t,e,n,l,r,$,u,p;return e=new S({props:{$$slots:{default:[St]},$$scope:{ctx:a}}}),l=new S({props:{$$slots:{default:[yt]},$$scope:{ctx:a}}}),$=new S({props:{$$slots:{default:[zt]},$$scope:{ctx:a}}}),{c(){t=_("setContext() takes a "),x(e.$$.fragment),n=_(" and a "),x(l.$$.fragment),r=_(" as parameters. The context is set and get upon "),x($.$$.fragment),u=_(" (whenever it is mounted in the DOM).")},l(o){t=d(o,"setContext() takes a "),T(e.$$.fragment,o),n=d(o," and a "),T(l.$$.fragment,o),r=d(o," as parameters. The context is set and get upon "),T($.$$.fragment,o),u=d(o," (whenever it is mounted in the DOM).")},m(o,c){w(o,t,c),C(e,o,c),w(o,n,c),C(l,o,c),w(o,r,c),C($,o,c),w(o,u,c),p=!0},p(o,c){const h={};c&2&&(h.$$scope={dirty:c,ctx:o}),e.$set(h);const g={};c&2&&(g.$$scope={dirty:c,ctx:o}),l.$set(g);const m={};c&2&&(m.$$scope={dirty:c,ctx:o}),$.$set(m)},i(o){p||(G(e.$$.fragment,o),G(l.$$.fragment,o),G($.$$.fragment,o),p=!0)},o(o){A(e.$$.fragment,o),A(l.$$.fragment,o),A($.$$.fragment,o),p=!1},d(o){o&&f(t),E(e,o),o&&f(n),E(l,o),o&&f(r),E($,o),o&&f(u)}}}function Pt(a){let t;return{c(){t=_("set an initial value")},l(e){t=d(e,"set an initial value")},m(e,n){w(e,t,n)},d(e){e&&f(t)}}}function qt(a){let t;return{c(){t=_("the other won't change")},l(e){t=d(e,"the other won't change")},m(e,n){w(e,t,n)},d(e){e&&f(t)}}}function Lt(a){let t;return{c(){t=_("not by reference")},l(e){t=d(e,"not by reference")},m(e,n){w(e,t,n)},d(e){e&&f(t)}}}function jt(a){let t,e,n,l,r,$,u,p;return e=new S({props:{$$slots:{default:[Pt]},$$scope:{ctx:a}}}),l=new S({props:{$$slots:{default:[qt]},$$scope:{ctx:a}}}),$=new S({props:{$$slots:{default:[Lt]},$$scope:{ctx:a}}}),{c(){t=_("This means that we can "),x(e.$$.fragment),n=_(" but after that if we increase count in one of the components "),x(l.$$.fragment),r=_(" because we're getting the value by value, "),x($.$$.fragment),u=_(".")},l(o){t=d(o,"This means that we can "),T(e.$$.fragment,o),n=d(o," but after that if we increase count in one of the components "),T(l.$$.fragment,o),r=d(o," because we're getting the value by value, "),T($.$$.fragment,o),u=d(o,".")},m(o,c){w(o,t,c),C(e,o,c),w(o,n,c),C(l,o,c),w(o,r,c),C($,o,c),w(o,u,c),p=!0},p(o,c){const h={};c&2&&(h.$$scope={dirty:c,ctx:o}),e.$set(h);const g={};c&2&&(g.$$scope={dirty:c,ctx:o}),l.$set(g);const m={};c&2&&(m.$$scope={dirty:c,ctx:o}),$.$set(m)},i(o){p||(G(e.$$.fragment,o),G(l.$$.fragment,o),G($.$$.fragment,o),p=!0)},o(o){A(e.$$.fragment,o),A(l.$$.fragment,o),A($.$$.fragment,o),p=!1},d(o){o&&f(t),E(e,o),o&&f(n),E(l,o),o&&f(r),E($,o),o&&f(u)}}}function Ht(a){let t;return{c(){t=_("This is the reason we're going to use a store in combination with context.")},l(e){t=d(e,"This is the reason we're going to use a store in combination with context.")},m(e,n){w(e,t,n)},d(e){e&&f(t)}}}function Kt(a){let t;return{c(){t=_("Let's try to sync the value using a store.")},l(e){t=d(e,"Let's try to sync the value using a store.")},m(e,n){w(e,t,n)},d(e){e&&f(t)}}}function Qt(a){let t;return{c(){t=_("store in combination with context")},l(e){t=d(e,"store in combination with context")},m(e,n){w(e,t,n)},d(e){e&&f(t)}}}function Zt(a){let t,e,n,l;return e=new S({props:{$$slots:{default:[Qt]},$$scope:{ctx:a}}}),{c(){t=_("It works! If we want to sync values down the chain of components we can use "),x(e.$$.fragment),n=_(".")},l(r){t=d(r,"It works! If we want to sync values down the chain of components we can use "),T(e.$$.fragment,r),n=d(r,".")},m(r,$){w(r,t,$),C(e,r,$),w(r,n,$),l=!0},p(r,$){const u={};$&2&&(u.$$scope={dirty:$,ctx:r}),e.$set(u)},i(r){l||(G(e.$$.fragment,r),l=!0)},o(r){A(e.$$.fragment,r),l=!1},d(r){r&&f(t),E(e,r),r&&f(n)}}}function Ft(a){let t,e,n,l,r,$,u,p,o,c,h,g,m,B,i,v,N,M;return t=new z({props:{$$slots:{default:[Dt]},$$scope:{ctx:a}}}),n=new z({props:{$$slots:{default:[Mt]},$$scope:{ctx:a}}}),r=new z({props:{$$slots:{default:[Vt]},$$scope:{ctx:a}}}),u=new z({props:{$$slots:{default:[jt]},$$scope:{ctx:a}}}),o=new z({props:{$$slots:{default:[Ht]},$$scope:{ctx:a}}}),h=new st({props:{name:[{name:"App",comp:Q,raw:vt,text:"This is an example where the value is synced once at component initialization but then loses sync."},{name:"Child",comp:Q,raw:bt,text:""},{name:"Grandchildren",comp:Q,raw:kt,text:""}]}}),m=new z({props:{$$slots:{default:[Kt]},$$scope:{ctx:a}}}),i=new st({props:{name:[{name:"App2",comp:Z,raw:It,text:"Here we're using a writable store."},{name:"Child2",comp:Z,raw:Bt,text:""},{name:"Grandchildren2",comp:Z,raw:Nt,text:""}]}}),N=new z({props:{$$slots:{default:[Zt]},$$scope:{ctx:a}}}),{c(){x(t.$$.fragment),e=O(),x(n.$$.fragment),l=O(),x(r.$$.fragment),$=O(),x(u.$$.fragment),p=O(),x(o.$$.fragment),c=O(),x(h.$$.fragment),g=O(),x(m.$$.fragment),B=O(),x(i.$$.fragment),v=O(),x(N.$$.fragment)},l(s){T(t.$$.fragment,s),e=I(s),T(n.$$.fragment,s),l=I(s),T(r.$$.fragment,s),$=I(s),T(u.$$.fragment,s),p=I(s),T(o.$$.fragment,s),c=I(s),T(h.$$.fragment,s),g=I(s),T(m.$$.fragment,s),B=I(s),T(i.$$.fragment,s),v=I(s),T(N.$$.fragment,s)},m(s,b){C(t,s,b),w(s,e,b),C(n,s,b),w(s,l,b),C(r,s,b),w(s,$,b),C(u,s,b),w(s,p,b),C(o,s,b),w(s,c,b),C(h,s,b),w(s,g,b),C(m,s,b),w(s,B,b),C(i,s,b),w(s,v,b),C(N,s,b),M=!0},p(s,b){const J={};b&2&&(J.$$scope={dirty:b,ctx:s}),t.$set(J);const W={};b&2&&(W.$$scope={dirty:b,ctx:s}),n.$set(W);const X={};b&2&&(X.$$scope={dirty:b,ctx:s}),r.$set(X);const Y={};b&2&&(Y.$$scope={dirty:b,ctx:s}),u.$set(Y);const tt={};b&2&&(tt.$$scope={dirty:b,ctx:s}),o.$set(tt);const et={};b&2&&(et.$$scope={dirty:b,ctx:s}),m.$set(et);const nt={};b&2&&(nt.$$scope={dirty:b,ctx:s}),N.$set(nt)},i(s){M||(G(t.$$.fragment,s),G(n.$$.fragment,s),G(r.$$.fragment,s),G(u.$$.fragment,s),G(o.$$.fragment,s),G(h.$$.fragment,s),G(m.$$.fragment,s),G(i.$$.fragment,s),G(N.$$.fragment,s),M=!0)},o(s){A(t.$$.fragment,s),A(n.$$.fragment,s),A(r.$$.fragment,s),A(u.$$.fragment,s),A(o.$$.fragment,s),A(h.$$.fragment,s),A(m.$$.fragment,s),A(i.$$.fragment,s),A(N.$$.fragment,s),M=!1},d(s){E(t,s),s&&f(e),E(n,s),s&&f(l),E(r,s),s&&f($),E(u,s),s&&f(p),E(o,s),s&&f(c),E(h,s),s&&f(g),E(m,s),s&&f(B),E(i,s),s&&f(v),E(N,s)}}}function Jt(a){let t,e;const n=[a[0],lt];let l={$$slots:{default:[Ft]},$$scope:{ctx:a}};for(let r=0;r<n.length;r+=1)l=F(l,n[r]);return t=new ut({props:l}),{c(){x(t.$$.fragment)},l(r){T(t.$$.fragment,r)},m(r,$){C(t,r,$),e=!0},p(r,[$]){const u=$&1?ft(n,[$&1&&rt(r[0]),$&0&&rt(lt)]):{};$&2&&(u.$$scope={dirty:$,ctx:r}),t.$set(u)},i(r){e||(G(t.$$.fragment,r),e=!0)},o(r){A(t.$$.fragment,r),e=!1},d(r){E(t,r)}}}const lt={title:"Reactive context",author:"henrikvilhelmberglund",authorlink:"github.com/henrikvilhelmberglund/",date:"2023-03-31T00:00:00.000Z",layout:"notes"};function Wt(a,t,e){return a.$$set=n=>{e(0,t=F(F({},t),ot(n)))},t=ot(t),[t]}class re extends V{constructor(t){super(),P(this,t,Wt,Jt,q,{})}}export{re as default,lt as metadata};
