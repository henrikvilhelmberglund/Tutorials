import{s as I,f as ee,l as c,g as te,h as ne,m as i,d as f,i as p,v as q,n as re,z as E,o as oe,C as Z,D as V,a as M,c as A}from"./scheduler.a7cd560e.js";import{S as L,i as P,b as w,d as b,m as v,a as d,t as h,e as S}from"./index.396264e7.js";import{g as $e,a as W}from"./HR.svelte_svelte_type_style_lang.8355a705.js";import{M as ae,P as B}from"./mdsvex-layout-notes.4b2b7ac6.js";import{r as se}from"./index.5e192797.js";import{S as X}from"./ShowMany.db7be1f3.js";import{S as x}from"./Strong.097578ae.js";let ue=se("Hello",u=>{let e=setTimeout(()=>{u("world")},1e3);return()=>{clearTimeout(e)}});function le(u){let e,t,s;return{c(){e=ee("h1"),t=c("value: "),s=c(u[0])},l(r){e=te(r,"H1",{});var $=ne(e);t=i($,"value: "),s=i($,u[0]),$.forEach(f)},m(r,$){p(r,e,$),q(e,t),q(e,s)},p(r,[$]){$&1&&re(s,r[0])},i:E,o:E,d(r){r&&f(e)}}}function fe(u,e,t){let s;return oe(()=>ue.subscribe(r=>{t(0,s=r)})),[s]}class me extends L{constructor(e){super(),P(this,e,fe,le,I,{})}}function pe(u){let e,t;return e=new me({}),{c(){w(e.$$.fragment)},l(s){b(e.$$.fragment,s)},m(s,r){v(e,s,r),t=!0},p:E,i(s){t||(d(e.$$.fragment,s),t=!0)},o(s){h(e.$$.fragment,s),t=!1},d(s){S(e,s)}}}class z extends L{constructor(e){super(),P(this,e,null,pe,I,{})}}const ce=`<script>\r
	import Output from "./Output.svelte";\r
<\/script>\r
\r
<Output />\r
`,ie=`<script>\r
	import { valueStore } from "./data";\r
	import { onMount } from "svelte";\r
\r
	let _value;\r
\r
	onMount(() => {\r
		return valueStore.subscribe((value) => {\r
			_value = value;\r
		});\r
	});\r
<\/script>\r
\r
<h1>value: {_value}</h1>\r
`,_e=`import { writable, readable } from "svelte/store";\r
\r
export let valueStore = readable("Hello", (set) => {\r
	let timer = setTimeout(() => {\r
		set("world");\r
	}, 1000);\r
\r
	return () => {\r
		clearTimeout(timer);\r
	};\r
});\r
`;let ge=se("Hello",u=>{console.log("Start (someone subscribed!)");let e=setTimeout(()=>{u("world")},1e3);return()=>{console.log("Stop (everyone unsubscribed!)"),clearTimeout(e)}});const we=ge.subscribe(function(){});setTimeout(()=>{we()},5e3);function be(u){let e,t,s;return{c(){e=ee("h1"),t=c("value: "),s=c(u[0])},l(r){e=te(r,"H1",{});var $=ne(e);t=i($,"value: "),s=i($,u[0]),$.forEach(f)},m(r,$){p(r,e,$),q(e,t),q(e,s)},p:E,i:E,o:E,d(r){r&&f(e)}}}function ve(u){let e;return[e]}class de extends L{constructor(e){super(),P(this,e,ve,be,I,{})}}function he(u){let e,t;return e=new de({}),{c(){w(e.$$.fragment)},l(s){b(e.$$.fragment,s)},m(s,r){v(e,s,r),t=!0},p:E,i(s){t||(d(e.$$.fragment,s),t=!0)},o(s){h(e.$$.fragment,s),t=!1},d(s){S(e,s)}}}class D extends L{constructor(e){super(),P(this,e,null,he,I,{})}}const Se=`<script>\r
	import Output2 from "./Output2.svelte";\r
<\/script>\r
\r
<Output2 />\r
`,Te=`<script>\r
	import { valueStore } from "./data2";\r
	import { onMount } from "svelte";\r
\r
	let _value;\r
<\/script>\r
\r
<!-- this is undefined to make sure we don't have subscribers -->\r
<h1>value: {_value}</h1>\r
`,Oe=`import { writable, readable } from "svelte/store";\r
\r
export let valueStore = readable("Hello", (set) => {\r
	console.log("Start (someone subscribed!)");\r
	let timer = setTimeout(() => {\r
		set("world");\r
	}, 1000);\r
\r
	return () => {\r
		console.log("Stop (everyone unsubscribed!)");\r
		clearTimeout(timer);\r
	};\r
});\r
\r
const unsub = valueStore.subscribe(function () {});\r
\r
setTimeout(() => {\r
	unsub();\r
}, 5000);\r
`;function xe(u){let e;return{c(){e=c("readable store")},l(t){e=i(t,"readable store")},m(t,s){p(t,e,s)},d(t){t&&f(e)}}}function He(u){let e;return{c(){e=c("read only")},l(t){e=i(t,"read only")},m(t,s){p(t,e,s)},d(t){t&&f(e)}}}function ke(u){let e,t,s,r,$,m;return t=new x({props:{$$slots:{default:[xe]},$$scope:{ctx:u}}}),r=new x({props:{$$slots:{default:[He]},$$scope:{ctx:u}}}),{c(){e=c("The "),w(t.$$.fragment),s=c(" is a "),w(r.$$.fragment),$=c(" store. But, if it's read only, how does the value change?")},l(n){e=i(n,"The "),b(t.$$.fragment,n),s=i(n," is a "),b(r.$$.fragment,n),$=i(n," store. But, if it's read only, how does the value change?")},m(n,a){p(n,e,a),v(t,n,a),p(n,s,a),v(r,n,a),p(n,$,a),m=!0},p(n,a){const g={};a&2&&(g.$$scope={dirty:a,ctx:n}),t.$set(g);const T={};a&2&&(T.$$scope={dirty:a,ctx:n}),r.$set(T)},i(n){m||(d(t.$$.fragment,n),d(r.$$.fragment,n),m=!0)},o(n){h(t.$$.fragment,n),h(r.$$.fragment,n),m=!1},d(n){n&&(f(e),f(s),f($)),S(t,n),S(r,n)}}}function Me(u){let e;return{c(){e=c("readable()")},l(t){e=i(t,"readable()")},m(t,s){p(t,e,s)},d(t){t&&f(e)}}}function Ae(u){let e;return{c(){e=c("initial value")},l(t){e=i(t,"initial value")},m(t,s){p(t,e,s)},d(t){t&&f(e)}}}function Re(u){let e,t,s,r,$,m;return t=new x({props:{$$slots:{default:[Me]},$$scope:{ctx:u}}}),r=new x({props:{$$slots:{default:[Ae]},$$scope:{ctx:u}}}),{c(){e=c("Like before the first argument in "),w(t.$$.fragment),s=c(" is the "),w(r.$$.fragment),$=c(" of the store.")},l(n){e=i(n,"Like before the first argument in "),b(t.$$.fragment,n),s=i(n," is the "),b(r.$$.fragment,n),$=i(n," of the store.")},m(n,a){p(n,e,a),v(t,n,a),p(n,s,a),v(r,n,a),p(n,$,a),m=!0},p(n,a){const g={};a&2&&(g.$$scope={dirty:a,ctx:n}),t.$set(g);const T={};a&2&&(T.$$scope={dirty:a,ctx:n}),r.$set(T)},i(n){m||(d(t.$$.fragment,n),d(r.$$.fragment,n),m=!0)},o(n){h(t.$$.fragment,n),h(r.$$.fragment,n),m=!1},d(n){n&&(f(e),f(s),f($)),S(t,n),S(r,n)}}}function je(u){let e;return{c(){e=c("mandatory second argument")},l(t){e=i(t,"mandatory second argument")},m(t,s){p(t,e,s)},d(t){t&&f(e)}}}function Ce(u){let e;return{c(){e=c("start stop notifier")},l(t){e=i(t,"start stop notifier")},m(t,s){p(t,e,s)},d(t){t&&f(e)}}}function Be(u){let e,t,s,r,$,m;return t=new x({props:{$$slots:{default:[je]},$$scope:{ctx:u}}}),r=new x({props:{$$slots:{default:[Ce]},$$scope:{ctx:u}}}),{c(){e=c("In addition, readable stores have a "),w(t.$$.fragment),s=c(" which is a so called "),w(r.$$.fragment),$=c(".")},l(n){e=i(n,"In addition, readable stores have a "),b(t.$$.fragment,n),s=i(n," which is a so called "),b(r.$$.fragment,n),$=i(n,".")},m(n,a){p(n,e,a),v(t,n,a),p(n,s,a),v(r,n,a),p(n,$,a),m=!0},p(n,a){const g={};a&2&&(g.$$scope={dirty:a,ctx:n}),t.$set(g);const T={};a&2&&(T.$$scope={dirty:a,ctx:n}),r.$set(T)},i(n){m||(d(t.$$.fragment,n),d(r.$$.fragment,n),m=!0)},o(n){h(t.$$.fragment,n),h(r.$$.fragment,n),m=!1},d(n){n&&(f(e),f(s),f($)),S(t,n),S(r,n)}}}function Ee(u){let e;return{c(){e=c("someone subscribes")},l(t){e=i(t,"someone subscribes")},m(t,s){p(t,e,s)},d(t){t&&f(e)}}}function Ie(u){let e;return{c(){e=c("first time")},l(t){e=i(t,"first time")},m(t,s){p(t,e,s)},d(t){t&&f(e)}}}function Le(u){let e,t,s,r,$,m;return t=new x({props:{$$slots:{default:[Ee]},$$scope:{ctx:u}}}),r=new x({props:{$$slots:{default:[Ie]},$$scope:{ctx:u}}}),{c(){e=c("This function is run when "),w(t.$$.fragment),s=c(" to the store for the "),w(r.$$.fragment),$=c(".")},l(n){e=i(n,"This function is run when "),b(t.$$.fragment,n),s=i(n," to the store for the "),b(r.$$.fragment,n),$=i(n,".")},m(n,a){p(n,e,a),v(t,n,a),p(n,s,a),v(r,n,a),p(n,$,a),m=!0},p(n,a){const g={};a&2&&(g.$$scope={dirty:a,ctx:n}),t.$set(g);const T={};a&2&&(T.$$scope={dirty:a,ctx:n}),r.$set(T)},i(n){m||(d(t.$$.fragment,n),d(r.$$.fragment,n),m=!0)},o(n){h(t.$$.fragment,n),h(r.$$.fragment,n),m=!1},d(n){n&&(f(e),f(s),f($)),S(t,n),S(r,n)}}}function Pe(u){let e;return{c(){e=c("clean up function")},l(t){e=i(t,"clean up function")},m(t,s){p(t,e,s)},d(t){t&&f(e)}}}function Ye(u){let e;return{c(){e=c("return statement")},l(t){e=i(t,"return statement")},m(t,s){p(t,e,s)},d(t){t&&f(e)}}}function qe(u){let e;return{c(){e=c("all unsubscribe")},l(t){e=i(t,"all unsubscribe")},m(t,s){p(t,e,s)},d(t){t&&f(e)}}}function ze(u){let e;return{c(){e=c("0")},l(t){e=i(t,"0")},m(t,s){p(t,e,s)},d(t){t&&f(e)}}}function De(u){let e,t,s,r,$,m,n,a,g,T;return t=new x({props:{$$slots:{default:[Pe]},$$scope:{ctx:u}}}),r=new x({props:{$$slots:{default:[Ye]},$$scope:{ctx:u}}}),m=new x({props:{$$slots:{default:[qe]},$$scope:{ctx:u}}}),a=new x({props:{$$slots:{default:[ze]},$$scope:{ctx:u}}}),{c(){e=c("You can also have a "),w(t.$$.fragment),s=c(" as a "),w(r.$$.fragment),$=c(" that will run when the subscribers "),w(m.$$.fragment),n=c(" so there are "),w(a.$$.fragment),g=c(" subscribers.")},l(l){e=i(l,"You can also have a "),b(t.$$.fragment,l),s=i(l," as a "),b(r.$$.fragment,l),$=i(l," that will run when the subscribers "),b(m.$$.fragment,l),n=i(l," so there are "),b(a.$$.fragment,l),g=i(l," subscribers.")},m(l,O){p(l,e,O),v(t,l,O),p(l,s,O),v(r,l,O),p(l,$,O),v(m,l,O),p(l,n,O),v(a,l,O),p(l,g,O),T=!0},p(l,O){const k={};O&2&&(k.$$scope={dirty:O,ctx:l}),t.$set(k);const R={};O&2&&(R.$$scope={dirty:O,ctx:l}),r.$set(R);const H={};O&2&&(H.$$scope={dirty:O,ctx:l}),m.$set(H);const j={};O&2&&(j.$$scope={dirty:O,ctx:l}),a.$set(j)},i(l){T||(d(t.$$.fragment,l),d(r.$$.fragment,l),d(m.$$.fragment,l),d(a.$$.fragment,l),T=!0)},o(l){h(t.$$.fragment,l),h(r.$$.fragment,l),h(m.$$.fragment,l),h(a.$$.fragment,l),T=!1},d(l){l&&(f(e),f(s),f($),f(n),f(g)),S(t,l),S(r,l),S(m,l),S(a,l)}}}function Ze(u){let e;return{c(){e=c("start stop notifier")},l(t){e=i(t,"start stop notifier")},m(t,s){p(t,e,s)},d(t){t&&f(e)}}}function Fe(u){let e;return{c(){e=c("set")},l(t){e=i(t,"set")},m(t,s){p(t,e,s)},d(t){t&&f(e)}}}function Ge(u){let e,t,s,r,$,m;return t=new x({props:{$$slots:{default:[Ze]},$$scope:{ctx:u}}}),r=new x({props:{$$slots:{default:[Fe]},$$scope:{ctx:u}}}),{c(){e=c("The parameter for the "),w(t.$$.fragment),s=c(" is "),w(r.$$.fragment),$=c(" (same as the writable store method).")},l(n){e=i(n,"The parameter for the "),b(t.$$.fragment,n),s=i(n," is "),b(r.$$.fragment,n),$=i(n," (same as the writable store method).")},m(n,a){p(n,e,a),v(t,n,a),p(n,s,a),v(r,n,a),p(n,$,a),m=!0},p(n,a){const g={};a&2&&(g.$$scope={dirty:a,ctx:n}),t.$set(g);const T={};a&2&&(T.$$scope={dirty:a,ctx:n}),r.$set(T)},i(n){m||(d(t.$$.fragment,n),d(r.$$.fragment,n),m=!0)},o(n){h(t.$$.fragment,n),h(r.$$.fragment,n),m=!1},d(n){n&&(f(e),f(s),f($)),S(t,n),S(r,n)}}}function Je(u){let e;return{c(){e=c("Here is an example where we console log when we subscribe and unsubscribe:")},l(t){e=i(t,"Here is an example where we console log when we subscribe and unsubscribe:")},m(t,s){p(t,e,s)},d(t){t&&f(e)}}}function Ke(u){let e,t,s,r,$,m,n,a,g,T,l,O,k,R,H,j,C,Y;return e=new B({props:{$$slots:{default:[ke]},$$scope:{ctx:u}}}),s=new B({props:{$$slots:{default:[Re]},$$scope:{ctx:u}}}),$=new B({props:{$$slots:{default:[Be]},$$scope:{ctx:u}}}),n=new B({props:{$$slots:{default:[Le]},$$scope:{ctx:u}}}),g=new B({props:{$$slots:{default:[De]},$$scope:{ctx:u}}}),l=new B({props:{$$slots:{default:[Ge]},$$scope:{ctx:u}}}),k=new X({props:{name:[{name:"App",comp:z,raw:ce,text:'Here we can see the value changing from "hello" to "world" since we use set() after a Timeout.'},{name:"Output",comp:z,raw:ie,text:""},{name:"data.js",comp:z,raw:_e,text:""}]}}),H=new B({props:{$$slots:{default:[Je]},$$scope:{ctx:u}}}),C=new X({props:{name:[{name:"App2",comp:D,raw:Se,text:"Check the console to see the messages."},{name:"Output2",comp:D,raw:Te,text:""},{name:"data2.js",comp:D,raw:Oe,text:""}]}}),{c(){w(e.$$.fragment),t=M(),w(s.$$.fragment),r=M(),w($.$$.fragment),m=M(),w(n.$$.fragment),a=M(),w(g.$$.fragment),T=M(),w(l.$$.fragment),O=M(),w(k.$$.fragment),R=M(),w(H.$$.fragment),j=M(),w(C.$$.fragment)},l(o){b(e.$$.fragment,o),t=A(o),b(s.$$.fragment,o),r=A(o),b($.$$.fragment,o),m=A(o),b(n.$$.fragment,o),a=A(o),b(g.$$.fragment,o),T=A(o),b(l.$$.fragment,o),O=A(o),b(k.$$.fragment,o),R=A(o),b(H.$$.fragment,o),j=A(o),b(C.$$.fragment,o)},m(o,_){v(e,o,_),p(o,t,_),v(s,o,_),p(o,r,_),v($,o,_),p(o,m,_),v(n,o,_),p(o,a,_),v(g,o,_),p(o,T,_),v(l,o,_),p(o,O,_),v(k,o,_),p(o,R,_),v(H,o,_),p(o,j,_),v(C,o,_),Y=!0},p(o,_){const F={};_&2&&(F.$$scope={dirty:_,ctx:o}),e.$set(F);const G={};_&2&&(G.$$scope={dirty:_,ctx:o}),s.$set(G);const J={};_&2&&(J.$$scope={dirty:_,ctx:o}),$.$set(J);const K={};_&2&&(K.$$scope={dirty:_,ctx:o}),n.$set(K);const N={};_&2&&(N.$$scope={dirty:_,ctx:o}),g.$set(N);const Q={};_&2&&(Q.$$scope={dirty:_,ctx:o}),l.$set(Q);const U={};_&2&&(U.$$scope={dirty:_,ctx:o}),H.$set(U)},i(o){Y||(d(e.$$.fragment,o),d(s.$$.fragment,o),d($.$$.fragment,o),d(n.$$.fragment,o),d(g.$$.fragment,o),d(l.$$.fragment,o),d(k.$$.fragment,o),d(H.$$.fragment,o),d(C.$$.fragment,o),Y=!0)},o(o){h(e.$$.fragment,o),h(s.$$.fragment,o),h($.$$.fragment,o),h(n.$$.fragment,o),h(g.$$.fragment,o),h(l.$$.fragment,o),h(k.$$.fragment,o),h(H.$$.fragment,o),h(C.$$.fragment,o),Y=!1},d(o){o&&(f(t),f(r),f(m),f(a),f(T),f(O),f(R),f(j)),S(e,o),S(s,o),S($,o),S(n,o),S(g,o),S(l,o),S(k,o),S(H,o),S(C,o)}}}function Ne(u){let e,t;const s=[u[0],y];let r={$$slots:{default:[Ke]},$$scope:{ctx:u}};for(let $=0;$<s.length;$+=1)r=Z(r,s[$]);return e=new ae({props:r}),{c(){w(e.$$.fragment)},l($){b(e.$$.fragment,$)},m($,m){v(e,$,m),t=!0},p($,[m]){const n=m&1?$e(s,[m&1&&W($[0]),m&0&&W(y)]):{};m&2&&(n.$$scope={dirty:m,ctx:$}),e.$set(n)},i($){t||(d(e.$$.fragment,$),t=!0)},o($){h(e.$$.fragment,$),t=!1},d($){S(e,$)}}}const y={title:"readable store",author:"henrikvilhelmberglund",authorlink:"github.com/henrikvilhelmberglund/",date:"2023-02-12T00:00:00.000Z",layout:"notes"};function Qe(u,e,t){return u.$$set=s=>{t(0,e=Z(Z({},e),V(s)))},e=V(e),[e]}class nt extends L{constructor(e){super(),P(this,e,Qe,Ne,I,{})}}export{nt as default,y as metadata};
