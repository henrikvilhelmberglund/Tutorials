import{s as H,f as N,a as T,l as c,g as C,c as R,h as ne,m as i,d as o,j as se,i as p,v as J,X as re,n as Re,z as O,o as Ke,C as xe,D as Xe}from"./scheduler.a7cd560e.js";import{S as V,i as E,b as g,d as w,m as v,a as h,t as d,e as b}from"./index.396264e7.js";import{g as Le,a as Ze}from"./HR.svelte_svelte_type_style_lang.8355a705.js";import{M as Qe,P as W}from"./mdsvex-layout-notes.4b2b7ac6.js";import{S as te}from"./ShowMany.db7be1f3.js";import{S}from"./Strong.097578ae.js";function ye(u){let e,t,s,$,n,a,l;return{c(){e=N("input"),t=T(),s=N("h1"),$=c("value: "),n=c(u[0]),this.h()},l(I){e=C(I,"INPUT",{type:!0}),t=R(I),s=C(I,"H1",{});var f=ne(s);$=i(f,"value: "),n=i(f,u[0]),f.forEach(o),this.h()},h(){se(e,"type","text")},m(I,f){p(I,e,f),p(I,t,f),p(I,s,f),J(s,$),J(s,n),a||(l=re(e,"input",u[2]),a=!0)},p(I,[f]){f&1&&Re(n,I[0])},i:O,o:O,d(I){I&&(o(e),o(t),o(s)),a=!1,l()}}}function et(u,e,t){let s="";function $(a){t(0,s=a)}return[s,$,a=>$(a.currentTarget.value)]}class tt extends V{constructor(e){super(),E(this,e,et,ye,H,{})}}function nt(u){let e,t;return e=new tt({}),{c(){g(e.$$.fragment)},l(s){w(e.$$.fragment,s)},m(s,$){v(e,s,$),t=!0},p:O,i(s){t||(h(e.$$.fragment,s),t=!0)},o(s){d(e.$$.fragment,s),t=!1},d(s){b(e,s)}}}class ve extends V{constructor(e){super(),E(this,e,null,nt,H,{})}}const st=`<script>\r
	import Sample from "./Sample.svelte";\r
<\/script>\r
\r
<Sample />\r
`,rt=`<script>\r
	let value = "";\r
\r
	function update(newValue) {\r
		value = newValue;\r
	}\r
<\/script>\r
\r
<input on:input={(e) => update(e.currentTarget.value)} type="text" />\r
\r
<h1>value: {value}</h1>\r
`;function $t(u){let e,t,s;return{c(){e=N("input"),this.h()},l($){e=C($,"INPUT",{type:!0}),this.h()},h(){se(e,"type","text")},m($,n){p($,e,n),t||(s=re(e,"input",u[1]),t=!0)},p:O,i:O,o:O,d($){$&&o(e),t=!1,s()}}}function ut(u){function e(s){}return[e,s=>(s.currentTarget.value,void 0)]}class at extends V{constructor(e){super(),E(this,e,ut,$t,H,{})}}const ot=`<script>\r
	let value = "";\r
\r
	function update(newValue) {\r
		value = newValue;\r
	}\r
<\/script>\r
\r
<input on:input={(e) => update(e.currentTarget.value)} type="text" />\r
`;function pt(u){let e,t,s;return{c(){e=N("h1"),t=c("value: "),s=c(Be)},l($){e=C($,"H1",{});var n=ne(e);t=i(n,"value: "),s=i(n,Be),n.forEach(o)},m($,n){p($,e,n),J(e,t),J(e,s)},p:O,i:O,o:O,d($){$&&o(e)}}}let Be="";class ft extends V{constructor(e){super(),E(this,e,null,pt,H,{})}}const lt=`<script>\r
	let value = "";\r
<\/script>\r
\r
<h1>value: {value}</h1>\r
`;function mt(u){let e,t,s,$;return e=new at({}),s=new ft({}),{c(){g(e.$$.fragment),t=T(),g(s.$$.fragment)},l(n){w(e.$$.fragment,n),t=R(n),w(s.$$.fragment,n)},m(n,a){v(e,n,a),p(n,t,a),v(s,n,a),$=!0},p:O,i(n){$||(h(e.$$.fragment,n),h(s.$$.fragment,n),$=!0)},o(n){d(e.$$.fragment,n),d(s.$$.fragment,n),$=!1},d(n){n&&o(t),b(e,n),b(s,n)}}}class ct extends V{constructor(e){super(),E(this,e,null,mt,H,{})}}const it=`<script>\r
	import Input from "./Input.svelte";\r
	import Output from "./Output.svelte";\r
<\/script>\r
\r
<Input />\r
<Output />\r
`;let Oe="";function _t(u){Oe=u}function gt(u){let e,t,s;return{c(){e=N("input"),this.h()},l($){e=C($,"INPUT",{type:!0}),this.h()},h(){se(e,"type","text")},m($,n){p($,e,n),t||(s=re(e,"input",u[0]),t=!0)},p:O,i:O,o:O,d($){$&&o(e),t=!1,s()}}}function wt(u){return[t=>_t(t.currentTarget.value)]}class vt extends V{constructor(e){super(),E(this,e,wt,gt,H,{})}}const ht=`<script>\r
	import { update } from "./data";\r
<\/script>\r
\r
<input on:input={(e) => update(e.currentTarget.value)} type="text" />\r
`;function dt(u){let e,t,s;return{c(){e=N("h1"),t=c("value: "),s=c(Oe)},l($){e=C($,"H1",{});var n=ne(e);t=i(n,"value: "),s=i(n,Oe),n.forEach(o)},m($,n){p($,e,n),J(e,t),J(e,s)},p:O,i:O,o:O,d($){$&&o(e)}}}class bt extends V{constructor(e){super(),E(this,e,null,dt,H,{})}}const It=`<script>\r
	import { value } from "./data";\r
<\/script>\r
\r
<h1>value: {value}</h1>\r
`;function xt(u){let e,t,s,$;return e=new vt({}),s=new bt({}),{c(){g(e.$$.fragment),t=T(),g(s.$$.fragment)},l(n){w(e.$$.fragment,n),t=R(n),w(s.$$.fragment,n)},m(n,a){v(e,n,a),p(n,t,a),v(s,n,a),$=!0},p:O,i(n){$||(h(e.$$.fragment,n),h(s.$$.fragment,n),$=!0)},o(n){d(e.$$.fragment,n),d(s.$$.fragment,n),$=!1},d(n){n&&o(t),b(e,n),b(s,n)}}}class he extends V{constructor(e){super(),E(this,e,null,xt,H,{})}}const Ot=`<script>\r
	import Input2 from "./Input2.svelte";\r
	import Output2 from "./Output2.svelte";\r
<\/script>\r
\r
<Input2 />\r
<Output2 />\r
`,At=`export let value = "";\r
\r
export function update(newValue) {\r
  value = newValue;\r
}`;let Ae="";function Tt(u){Ae=u,Ge.forEach(e=>e())}let Ge=[];function Rt(u){Ge.push(u)}function St(u){let e,t,s;return{c(){e=N("input"),this.h()},l($){e=C($,"INPUT",{type:!0}),this.h()},h(){se(e,"type","text")},m($,n){p($,e,n),t||(s=re(e,"input",u[0]),t=!0)},p:O,i:O,o:O,d($){$&&o(e),t=!1,s()}}}function jt(u){return[t=>Tt(t.currentTarget.value)]}class Wt extends V{constructor(e){super(),E(this,e,jt,St,H,{})}}const kt=`<script>\r
	import { update } from "./data2";\r
<\/script>\r
\r
<input on:input={(e) => update(e.currentTarget.value)} type="text" />\r
`;function Ht(u){let e,t,s;return{c(){e=N("h1"),t=c("value: "),s=c(u[0])},l($){e=C($,"H1",{});var n=ne(e);t=i(n,"value: "),s=i(n,u[0]),n.forEach(o)},m($,n){p($,e,n),J(e,t),J(e,s)},p($,[n]){n&1&&Re(s,$[0])},i:O,o:O,d($){$&&o(e)}}}function Vt(u,e,t){let s=Ae;return Rt(()=>{t(0,s=Ae)}),[s]}class Et extends V{constructor(e){super(),E(this,e,Vt,Ht,H,{})}}const Mt=`<script>\r
	import { value, subscribe } from "./data2";\r
\r
  let _value = value;\r
	subscribe(() => {\r
		_value = value;\r
	});\r
<\/script>\r
\r
<h1>value: {_value}</h1>\r
`;function Pt(u){let e,t,s,$;return e=new Wt({}),s=new Et({}),{c(){g(e.$$.fragment),t=T(),g(s.$$.fragment)},l(n){w(e.$$.fragment,n),t=R(n),w(s.$$.fragment,n)},m(n,a){v(e,n,a),p(n,t,a),v(s,n,a),$=!0},p:O,i(n){$||(h(e.$$.fragment,n),h(s.$$.fragment,n),$=!0)},o(n){d(e.$$.fragment,n),d(s.$$.fragment,n),$=!1},d(n){n&&o(t),b(e,n),b(s,n)}}}class de extends V{constructor(e){super(),E(this,e,null,Pt,H,{})}}const Ut=`<script>\r
	import Input3 from "./Input3.svelte";\r
	import Output3 from "./Output3.svelte";\r
<\/script>\r
\r
<Input3 />\r
<Output3 />\r
`,Nt=`export let value = "";\r
\r
export function update(newValue) {\r
	value = newValue;\r
\r
	subscribers.forEach((fn) => fn());\r
}\r
\r
let subscribers = [];\r
\r
export function subscribe(fn) {\r
	subscribers.push(fn);\r
}\r
`;let Te="";function Ct(u){Te=u,Ie.forEach(e=>e())}let Ie=[];function Jt(u){return Ie.push(u),function(t){Ie.splice(Ie.indexOf(t),1)}}function Yt(u){let e,t,s;return{c(){e=N("input"),this.h()},l($){e=C($,"INPUT",{type:!0}),this.h()},h(){se(e,"type","text")},m($,n){p($,e,n),t||(s=re(e,"input",u[0]),t=!0)},p:O,i:O,o:O,d($){$&&o(e),t=!1,s()}}}function qt(u){return[t=>Ct(t.currentTarget.value)]}class zt extends V{constructor(e){super(),E(this,e,qt,Yt,H,{})}}const Dt=`<script>\r
	import { update } from "./data3";\r
<\/script>\r
\r
<input on:input={(e) => update(e.currentTarget.value)} type="text" />\r
`;function Xt(u){let e,t,s;return{c(){e=N("h1"),t=c("value: "),s=c(u[0])},l($){e=C($,"H1",{});var n=ne(e);t=i(n,"value: "),s=i(n,u[0]),n.forEach(o)},m($,n){p($,e,n),J(e,t),J(e,s)},p($,[n]){n&1&&Re(s,$[0])},i:O,o:O,d($){$&&o(e)}}}function Zt(u,e,t){let s=Te;return Ke(()=>Jt(()=>{t(0,s=Te)})),[s]}class Bt extends V{constructor(e){super(),E(this,e,Zt,Xt,H,{})}}const Ft=`<script>\r
	import { value, subscribe } from "./data3";\r
	import { onMount } from "svelte";\r
\r
	let _value = value;\r
\r
  // whenever the component is unmounted the returned unsubscribe function in\r
  // data3.js is run so the function is removed from the subscribers list\r
	onMount(() => {\r
		return subscribe(() => {\r
			_value = value;\r
		});\r
	});\r
<\/script>\r
\r
<h1>value: {_value}</h1>\r
`;function Gt(u){let e,t,s,$;return e=new zt({}),s=new Bt({}),{c(){g(e.$$.fragment),t=T(),g(s.$$.fragment)},l(n){w(e.$$.fragment,n),t=R(n),w(s.$$.fragment,n)},m(n,a){v(e,n,a),p(n,t,a),v(s,n,a),$=!0},p:O,i(n){$||(h(e.$$.fragment,n),h(s.$$.fragment,n),$=!0)},o(n){d(e.$$.fragment,n),d(s.$$.fragment,n),$=!1},d(n){n&&o(t),b(e,n),b(s,n)}}}class be extends V{constructor(e){super(),E(this,e,null,Gt,H,{})}}const Kt=`<script>\r
	import Input4 from "./Input4.svelte";\r
	import Output4 from "./Output4.svelte";\r
<\/script>\r
\r
<Input4 />\r
<Output4 />\r
`,Lt=`export let value = "";\r
\r
export function update(newValue) {\r
	value = newValue;\r
\r
	subscribers.forEach((fn) => fn());\r
}\r
\r
let subscribers = [];\r
\r
export function subscribe(fn) {\r
	subscribers.push(fn);\r
\r
	return function unsubscribe(fn) {\r
		subscribers.splice(subscribers.indexOf(fn), 1);\r
	};\r
}\r
`;function Qt(u){let e;return{c(){e=c("How do we share states across two components?")},l(t){e=i(t,"How do we share states across two components?")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function yt(u){let e;return{c(){e=c("Here we have a component that we're later going two split into two components, each handling a different task.")},l(t){e=i(t,"Here we have a component that we're later going two split into two components, each handling a different task.")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function en(u){let e;return{c(){e=c("After splitting it we have this:")},l(t){e=i(t,"After splitting it we have this:")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function tn(u){let e;return{c(){e=c("value")},l(t){e=i(t,"value")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function nn(u){let e,t,s,$;return t=new S({props:{$$slots:{default:[tn]},$$scope:{ctx:u}}}),{c(){e=c("How do we share the "),g(t.$$.fragment),s=c(" variable?")},l(n){e=i(n,"How do we share the "),w(t.$$.fragment,n),s=i(n," variable?")},m(n,a){p(n,e,a),v(t,n,a),p(n,s,a),$=!0},p(n,a){const l={};a&2&&(l.$$scope={dirty:a,ctx:n}),t.$set(l)},i(n){$||(h(t.$$.fragment,n),$=!0)},o(n){d(t.$$.fragment,n),$=!1},d(n){n&&(o(e),o(s)),b(t,n)}}}function sn(u){let e;return{c(){e=c("value")},l(t){e=i(t,"value")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function rn(u){let e;return{c(){e=c("props")},l(t){e=i(t,"props")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function $n(u){let e;return{c(){e=c("context")},l(t){e=i(t,"context")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function un(u){let e,t,s,$,n,a,l,I;return t=new S({props:{$$slots:{default:[sn]},$$scope:{ctx:u}}}),$=new S({props:{$$slots:{default:[rn]},$$scope:{ctx:u}}}),a=new S({props:{$$slots:{default:[$n]},$$scope:{ctx:u}}}),{c(){e=c("We could have "),g(t.$$.fragment),s=c(" in App2.svelte and pass the value by "),g($.$$.fragment),n=c(" or "),g(a.$$.fragment),l=c(", but perhaps we don't want have that value variable in App2.svelte since it's really only loading the components.")},l(f){e=i(f,"We could have "),w(t.$$.fragment,f),s=i(f," in App2.svelte and pass the value by "),w($.$$.fragment,f),n=i(f," or "),w(a.$$.fragment,f),l=i(f,", but perhaps we don't want have that value variable in App2.svelte since it's really only loading the components.")},m(f,x){p(f,e,x),v(t,f,x),p(f,s,x),v($,f,x),p(f,n,x),v(a,f,x),p(f,l,x),I=!0},p(f,x){const j={};x&2&&(j.$$scope={dirty:x,ctx:f}),t.$set(j);const k={};x&2&&(k.$$scope={dirty:x,ctx:f}),$.$set(k);const _={};x&2&&(_.$$scope={dirty:x,ctx:f}),a.$set(_)},i(f){I||(h(t.$$.fragment,f),h($.$$.fragment,f),h(a.$$.fragment,f),I=!0)},o(f){d(t.$$.fragment,f),d($.$$.fragment,f),d(a.$$.fragment,f),I=!1},d(f){f&&(o(e),o(s),o(n),o(l)),b(t,f),b($,f),b(a,f)}}}function an(u){let e;return{c(){e=c("data.js")},l(t){e=i(t,"data.js")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function on(u){let e,t,s,$;return t=new S({props:{$$slots:{default:[an]},$$scope:{ctx:u}}}),{c(){e=c("We could instead have another file called "),g(t.$$.fragment),s=c(" where we put the value variable and the function to update it, and import these into the Input and Output components.")},l(n){e=i(n,"We could instead have another file called "),w(t.$$.fragment,n),s=i(n," where we put the value variable and the function to update it, and import these into the Input and Output components.")},m(n,a){p(n,e,a),v(t,n,a),p(n,s,a),$=!0},p(n,a){const l={};a&2&&(l.$$scope={dirty:a,ctx:n}),t.$set(l)},i(n){$||(h(t.$$.fragment,n),$=!0)},o(n){d(t.$$.fragment,n),$=!1},d(n){n&&(o(e),o(s)),b(t,n)}}}function pn(u){let e;return{c(){e=c("doesn't work")},l(t){e=i(t,"doesn't work")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function fn(u){let e;return{c(){e=c("data.js")},l(t){e=i(t,"data.js")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function ln(u){let e;return{c(){e=c("Javascript file")},l(t){e=i(t,"Javascript file")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function mn(u){let e;return{c(){e=c("value")},l(t){e=i(t,"value")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function cn(u){let e;return{c(){e=c("reactive")},l(t){e=i(t,"reactive")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function _n(u){let e,t,s,$,n,a,l,I,f,x,j,k;return t=new S({props:{$$slots:{default:[pn]},$$scope:{ctx:u}}}),$=new S({props:{$$slots:{default:[fn]},$$scope:{ctx:u}}}),a=new S({props:{$$slots:{default:[ln]},$$scope:{ctx:u}}}),I=new S({props:{$$slots:{default:[mn]},$$scope:{ctx:u}}}),x=new S({props:{$$slots:{default:[cn]},$$scope:{ctx:u}}}),{c(){e=c("However, when we type we notice that it "),g(t.$$.fragment),s=c("! This is because "),g($.$$.fragment),n=c(" is a "),g(a.$$.fragment),l=c(" and not a .svelte file, so the "),g(I.$$.fragment),f=c(" variable isn't "),g(x.$$.fragment),j=c(".")},l(_){e=i(_,"However, when we type we notice that it "),w(t.$$.fragment,_),s=i(_,"! This is because "),w($.$$.fragment,_),n=i(_," is a "),w(a.$$.fragment,_),l=i(_," and not a .svelte file, so the "),w(I.$$.fragment,_),f=i(_," variable isn't "),w(x.$$.fragment,_),j=i(_,".")},m(_,A){p(_,e,A),v(t,_,A),p(_,s,A),v($,_,A),p(_,n,A),v(a,_,A),p(_,l,A),v(I,_,A),p(_,f,A),v(x,_,A),p(_,j,A),k=!0},p(_,A){const M={};A&2&&(M.$$scope={dirty:A,ctx:_}),t.$set(M);const L={};A&2&&(L.$$scope={dirty:A,ctx:_}),$.$set(L);const U={};A&2&&(U.$$scope={dirty:A,ctx:_}),a.$set(U);const Q={};A&2&&(Q.$$scope={dirty:A,ctx:_}),I.$set(Q);const P={};A&2&&(P.$$scope={dirty:A,ctx:_}),x.$set(P)},i(_){k||(h(t.$$.fragment,_),h($.$$.fragment,_),h(a.$$.fragment,_),h(I.$$.fragment,_),h(x.$$.fragment,_),k=!0)},o(_){d(t.$$.fragment,_),d($.$$.fragment,_),d(a.$$.fragment,_),d(I.$$.fragment,_),d(x.$$.fragment,_),k=!1},d(_){_&&(o(e),o(s),o(n),o(l),o(f),o(j)),b(t,_),b($,_),b(a,_),b(I,_),b(x,_)}}}function gn(u){let e;return{c(){e=c("Is there a way we can fix this?")},l(t){e=i(t,"Is there a way we can fix this?")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function wn(u){let e;return{c(){e=c("subscription model")},l(t){e=i(t,"subscription model")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function vn(u){let e,t,s,$;return t=new S({props:{$$slots:{default:[wn]},$$scope:{ctx:u}}}),{c(){e=c("We could try having a "),g(t.$$.fragment),s=c(" (event listener style) where we subscribe to the changes in data.js, when there's a change, we can rerender by ourselvees.")},l(n){e=i(n,"We could try having a "),w(t.$$.fragment,n),s=i(n," (event listener style) where we subscribe to the changes in data.js, when there's a change, we can rerender by ourselvees.")},m(n,a){p(n,e,a),v(t,n,a),p(n,s,a),$=!0},p(n,a){const l={};a&2&&(l.$$scope={dirty:a,ctx:n}),t.$set(l)},i(n){$||(h(t.$$.fragment,n),$=!0)},o(n){d(t.$$.fragment,n),$=!1},d(n){n&&(o(e),o(s)),b(t,n)}}}function hn(u){let e;return{c(){e=c("rerender")},l(t){e=i(t,"rerender")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function dn(u){let e,t,s,$;return t=new S({props:{$$slots:{default:[hn]},$$scope:{ctx:u}}}),{c(){e=c("We subscribe to the data and whenever the data changes we get notified and update the internal state (the _value variable) and since that was assigned in a .svelte file whenever _value changes we "),g(t.$$.fragment),s=c(".")},l(n){e=i(n,"We subscribe to the data and whenever the data changes we get notified and update the internal state (the _value variable) and since that was assigned in a .svelte file whenever _value changes we "),w(t.$$.fragment,n),s=i(n,".")},m(n,a){p(n,e,a),v(t,n,a),p(n,s,a),$=!0},p(n,a){const l={};a&2&&(l.$$scope={dirty:a,ctx:n}),t.$set(l)},i(n){$||(h(t.$$.fragment,n),$=!0)},o(n){d(t.$$.fragment,n),$=!1},d(n){n&&(o(e),o(s)),b(t,n)}}}function bn(u){let e;return{c(){e=c("This")},l(t){e=i(t,"This")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function In(u){let e;return{c(){e=c("Svelte store")},l(t){e=i(t,"Svelte store")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function xn(u){let e,t,s,$,n;return e=new S({props:{$$slots:{default:[bn]},$$scope:{ctx:u}}}),s=new S({props:{$$slots:{default:[In]},$$scope:{ctx:u}}}),{c(){g(e.$$.fragment),t=c(" is the concept of a "),g(s.$$.fragment),$=c(".")},l(a){w(e.$$.fragment,a),t=i(a," is the concept of a "),w(s.$$.fragment,a),$=i(a,".")},m(a,l){v(e,a,l),p(a,t,l),v(s,a,l),p(a,$,l),n=!0},p(a,l){const I={};l&2&&(I.$$scope={dirty:l,ctx:a}),e.$set(I);const f={};l&2&&(f.$$scope={dirty:l,ctx:a}),s.$set(f)},i(a){n||(h(e.$$.fragment,a),h(s.$$.fragment,a),n=!0)},o(a){d(e.$$.fragment,a),d(s.$$.fragment,a),n=!1},d(a){a&&(o(t),o($)),b(e,a),b(s,a)}}}function On(u){let e;return{c(){e=c("You can have a variable or some kind of state in your application that is not a part of your app component hierarchy, meaning it can live in a separate .js file.")},l(t){e=i(t,"You can have a variable or some kind of state in your application that is not a part of your app component hierarchy, meaning it can live in a separate .js file.")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function An(u){let e;return{c(){e=c("any component")},l(t){e=i(t,"any component")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function Tn(u){let e,t,s,$;return t=new S({props:{$$slots:{default:[An]},$$scope:{ctx:u}}}),{c(){e=c("We can then import that file and use the store in "),g(t.$$.fragment),s=c(" without paying attention to the relationships between the components.")},l(n){e=i(n,"We can then import that file and use the store in "),w(t.$$.fragment,n),s=i(n," without paying attention to the relationships between the components.")},m(n,a){p(n,e,a),v(t,n,a),p(n,s,a),$=!0},p(n,a){const l={};a&2&&(l.$$scope={dirty:a,ctx:n}),t.$set(l)},i(n){$||(h(t.$$.fragment,n),$=!0)},o(n){d(t.$$.fragment,n),$=!1},d(n){n&&(o(e),o(s)),b(t,n)}}}function Rn(u){let e;return{c(){e=c("way to change the value")},l(t){e=i(t,"way to change the value")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function Sn(u){let e;return{c(){e=c("subscribe")},l(t){e=i(t,"subscribe")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function jn(u){let e;return{c(){e=c("you get notified")},l(t){e=i(t,"you get notified")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function Wn(u){let e,t,s,$,n,a,l,I;return t=new S({props:{$$slots:{default:[Rn]},$$scope:{ctx:u}}}),$=new S({props:{$$slots:{default:[Sn]},$$scope:{ctx:u}}}),a=new S({props:{$$slots:{default:[jn]},$$scope:{ctx:u}}}),{c(){e=c("After that we provide a "),g(t.$$.fragment),s=c(" and a way to "),g($.$$.fragment),n=c(" to that value so when it changes "),g(a.$$.fragment),l=c(".")},l(f){e=i(f,"After that we provide a "),w(t.$$.fragment,f),s=i(f," and a way to "),w($.$$.fragment,f),n=i(f," to that value so when it changes "),w(a.$$.fragment,f),l=i(f,".")},m(f,x){p(f,e,x),v(t,f,x),p(f,s,x),v($,f,x),p(f,n,x),v(a,f,x),p(f,l,x),I=!0},p(f,x){const j={};x&2&&(j.$$scope={dirty:x,ctx:f}),t.$set(j);const k={};x&2&&(k.$$scope={dirty:x,ctx:f}),$.$set(k);const _={};x&2&&(_.$$scope={dirty:x,ctx:f}),a.$set(_)},i(f){I||(h(t.$$.fragment,f),h($.$$.fragment,f),h(a.$$.fragment,f),I=!0)},o(f){d(t.$$.fragment,f),d($.$$.fragment,f),d(a.$$.fragment,f),I=!1},d(f){f&&(o(e),o(s),o(n),o(l)),b(t,f),b($,f),b(a,f)}}}function kn(u){let e;return{c(){e=c("unsubscribe")},l(t){e=i(t,"unsubscribe")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function Hn(u){let e,t,s,$;return t=new S({props:{$$slots:{default:[kn]},$$scope:{ctx:u}}}),{c(){e=c("Whenever we subscribe we also need a way to "),g(t.$$.fragment),s=c(".")},l(n){e=i(n,"Whenever we subscribe we also need a way to "),w(t.$$.fragment,n),s=i(n,".")},m(n,a){p(n,e,a),v(t,n,a),p(n,s,a),$=!0},p(n,a){const l={};a&2&&(l.$$scope={dirty:a,ctx:n}),t.$set(l)},i(n){$||(h(t.$$.fragment,n),$=!0)},o(n){d(t.$$.fragment,n),$=!1},d(n){n&&(o(e),o(s)),b(t,n)}}}function Vn(u){let e;return{c(){e=c("unmonted")},l(t){e=i(t,"unmonted")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function En(u){let e,t,s,$;return t=new S({props:{$$slots:{default:[Vn]},$$scope:{ctx:u}}}),{c(){e=c("Unsubscribing in this way using onMount will make sure the subscribed function is removed when the component is "),g(t.$$.fragment),s=c(".")},l(n){e=i(n,"Unsubscribing in this way using onMount will make sure the subscribed function is removed when the component is "),w(t.$$.fragment,n),s=i(n,".")},m(n,a){p(n,e,a),v(t,n,a),p(n,s,a),$=!0},p(n,a){const l={};a&2&&(l.$$scope={dirty:a,ctx:n}),t.$set(l)},i(n){$||(h(t.$$.fragment,n),$=!0)},o(n){d(t.$$.fragment,n),$=!1},d(n){n&&(o(e),o(s)),b(t,n)}}}function Mn(u){let e;return{c(){e=c("store")},l(t){e=i(t,"store")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function Pn(u){let e;return{c(){e=c("store creation functions provided in Svelte")},l(t){e=i(t,"store creation functions provided in Svelte")},m(t,s){p(t,e,s)},d(t){t&&o(e)}}}function Un(u){let e,t,s,$,n,a;return t=new S({props:{$$slots:{default:[Mn]},$$scope:{ctx:u}}}),$=new S({props:{$$slots:{default:[Pn]},$$scope:{ctx:u}}}),{c(){e=c("We can implement a "),g(t.$$.fragment),s=c(" like this by ourselves or use the "),g($.$$.fragment),n=c(" which we'll do next.")},l(l){e=i(l,"We can implement a "),w(t.$$.fragment,l),s=i(l," like this by ourselves or use the "),w($.$$.fragment,l),n=i(l," which we'll do next.")},m(l,I){p(l,e,I),v(t,l,I),p(l,s,I),v($,l,I),p(l,n,I),a=!0},p(l,I){const f={};I&2&&(f.$$scope={dirty:I,ctx:l}),t.$set(f);const x={};I&2&&(x.$$scope={dirty:I,ctx:l}),$.$set(x)},i(l){a||(h(t.$$.fragment,l),h($.$$.fragment,l),a=!0)},o(l){d(t.$$.fragment,l),d($.$$.fragment,l),a=!1},d(l){l&&(o(e),o(s),o(n)),b(t,l),b($,l)}}}function Nn(u){let e,t,s,$,n,a,l,I,f,x,j,k,_,A,M,L,U,Q,P,$e,Y,ue,q,ae,y,oe,z,pe,D,fe,X,le,Z,me,B,ce,F,ie,ee,_e,G,ge,K,we;return e=new W({props:{$$slots:{default:[Qt]},$$scope:{ctx:u}}}),s=new W({props:{$$slots:{default:[yt]},$$scope:{ctx:u}}}),n=new te({props:{name:[{name:"App",comp:ve,raw:st,text:""},{name:"Sample",comp:ve,raw:rt}]}}),l=new W({props:{$$slots:{default:[en]},$$scope:{ctx:u}}}),f=new te({props:{name:[{name:"App2",comp:ct,raw:it,text:""},{name:"Input",comp:ve,raw:ot},{name:"Output",comp:ve,raw:lt}]}}),j=new W({props:{$$slots:{default:[nn]},$$scope:{ctx:u}}}),_=new W({props:{$$slots:{default:[un]},$$scope:{ctx:u}}}),M=new W({props:{$$slots:{default:[on]},$$scope:{ctx:u}}}),U=new te({props:{name:[{name:"App3",comp:he,raw:Ot,text:""},{name:"Input2",comp:he,raw:ht},{name:"Output2",comp:he,raw:It},{name:"data.js",comp:he,raw:At}]}}),P=new W({props:{$$slots:{default:[_n]},$$scope:{ctx:u}}}),Y=new W({props:{$$slots:{default:[gn]},$$scope:{ctx:u}}}),q=new W({props:{$$slots:{default:[vn]},$$scope:{ctx:u}}}),y=new te({props:{name:[{name:"App4",comp:de,raw:Ut,text:""},{name:"Input3",comp:de,raw:kt},{name:"Output3",comp:de,raw:Mt},{name:"data2.js",comp:de,raw:Nt}]}}),z=new W({props:{$$slots:{default:[dn]},$$scope:{ctx:u}}}),D=new W({props:{$$slots:{default:[xn]},$$scope:{ctx:u}}}),X=new W({props:{$$slots:{default:[On]},$$scope:{ctx:u}}}),Z=new W({props:{$$slots:{default:[Tn]},$$scope:{ctx:u}}}),B=new W({props:{$$slots:{default:[Wn]},$$scope:{ctx:u}}}),F=new W({props:{$$slots:{default:[Hn]},$$scope:{ctx:u}}}),ee=new te({props:{name:[{name:"App5",comp:be,raw:Kt,text:""},{name:"Input4",comp:be,raw:Dt},{name:"Output4",comp:be,raw:Ft},{name:"data3.js",comp:be,raw:Lt}]}}),G=new W({props:{$$slots:{default:[En]},$$scope:{ctx:u}}}),K=new W({props:{$$slots:{default:[Un]},$$scope:{ctx:u}}}),{c(){g(e.$$.fragment),t=T(),g(s.$$.fragment),$=T(),g(n.$$.fragment),a=T(),g(l.$$.fragment),I=T(),g(f.$$.fragment),x=T(),g(j.$$.fragment),k=T(),g(_.$$.fragment),A=T(),g(M.$$.fragment),L=T(),g(U.$$.fragment),Q=T(),g(P.$$.fragment),$e=T(),g(Y.$$.fragment),ue=T(),g(q.$$.fragment),ae=T(),g(y.$$.fragment),oe=T(),g(z.$$.fragment),pe=T(),g(D.$$.fragment),fe=T(),g(X.$$.fragment),le=T(),g(Z.$$.fragment),me=T(),g(B.$$.fragment),ce=T(),g(F.$$.fragment),ie=T(),g(ee.$$.fragment),_e=T(),g(G.$$.fragment),ge=T(),g(K.$$.fragment)},l(r){w(e.$$.fragment,r),t=R(r),w(s.$$.fragment,r),$=R(r),w(n.$$.fragment,r),a=R(r),w(l.$$.fragment,r),I=R(r),w(f.$$.fragment,r),x=R(r),w(j.$$.fragment,r),k=R(r),w(_.$$.fragment,r),A=R(r),w(M.$$.fragment,r),L=R(r),w(U.$$.fragment,r),Q=R(r),w(P.$$.fragment,r),$e=R(r),w(Y.$$.fragment,r),ue=R(r),w(q.$$.fragment,r),ae=R(r),w(y.$$.fragment,r),oe=R(r),w(z.$$.fragment,r),pe=R(r),w(D.$$.fragment,r),fe=R(r),w(X.$$.fragment,r),le=R(r),w(Z.$$.fragment,r),me=R(r),w(B.$$.fragment,r),ce=R(r),w(F.$$.fragment,r),ie=R(r),w(ee.$$.fragment,r),_e=R(r),w(G.$$.fragment,r),ge=R(r),w(K.$$.fragment,r)},m(r,m){v(e,r,m),p(r,t,m),v(s,r,m),p(r,$,m),v(n,r,m),p(r,a,m),v(l,r,m),p(r,I,m),v(f,r,m),p(r,x,m),v(j,r,m),p(r,k,m),v(_,r,m),p(r,A,m),v(M,r,m),p(r,L,m),v(U,r,m),p(r,Q,m),v(P,r,m),p(r,$e,m),v(Y,r,m),p(r,ue,m),v(q,r,m),p(r,ae,m),v(y,r,m),p(r,oe,m),v(z,r,m),p(r,pe,m),v(D,r,m),p(r,fe,m),v(X,r,m),p(r,le,m),v(Z,r,m),p(r,me,m),v(B,r,m),p(r,ce,m),v(F,r,m),p(r,ie,m),v(ee,r,m),p(r,_e,m),v(G,r,m),p(r,ge,m),v(K,r,m),we=!0},p(r,m){const Se={};m&2&&(Se.$$scope={dirty:m,ctx:r}),e.$set(Se);const je={};m&2&&(je.$$scope={dirty:m,ctx:r}),s.$set(je);const We={};m&2&&(We.$$scope={dirty:m,ctx:r}),l.$set(We);const ke={};m&2&&(ke.$$scope={dirty:m,ctx:r}),j.$set(ke);const He={};m&2&&(He.$$scope={dirty:m,ctx:r}),_.$set(He);const Ve={};m&2&&(Ve.$$scope={dirty:m,ctx:r}),M.$set(Ve);const Ee={};m&2&&(Ee.$$scope={dirty:m,ctx:r}),P.$set(Ee);const Me={};m&2&&(Me.$$scope={dirty:m,ctx:r}),Y.$set(Me);const Pe={};m&2&&(Pe.$$scope={dirty:m,ctx:r}),q.$set(Pe);const Ue={};m&2&&(Ue.$$scope={dirty:m,ctx:r}),z.$set(Ue);const Ne={};m&2&&(Ne.$$scope={dirty:m,ctx:r}),D.$set(Ne);const Ce={};m&2&&(Ce.$$scope={dirty:m,ctx:r}),X.$set(Ce);const Je={};m&2&&(Je.$$scope={dirty:m,ctx:r}),Z.$set(Je);const Ye={};m&2&&(Ye.$$scope={dirty:m,ctx:r}),B.$set(Ye);const qe={};m&2&&(qe.$$scope={dirty:m,ctx:r}),F.$set(qe);const ze={};m&2&&(ze.$$scope={dirty:m,ctx:r}),G.$set(ze);const De={};m&2&&(De.$$scope={dirty:m,ctx:r}),K.$set(De)},i(r){we||(h(e.$$.fragment,r),h(s.$$.fragment,r),h(n.$$.fragment,r),h(l.$$.fragment,r),h(f.$$.fragment,r),h(j.$$.fragment,r),h(_.$$.fragment,r),h(M.$$.fragment,r),h(U.$$.fragment,r),h(P.$$.fragment,r),h(Y.$$.fragment,r),h(q.$$.fragment,r),h(y.$$.fragment,r),h(z.$$.fragment,r),h(D.$$.fragment,r),h(X.$$.fragment,r),h(Z.$$.fragment,r),h(B.$$.fragment,r),h(F.$$.fragment,r),h(ee.$$.fragment,r),h(G.$$.fragment,r),h(K.$$.fragment,r),we=!0)},o(r){d(e.$$.fragment,r),d(s.$$.fragment,r),d(n.$$.fragment,r),d(l.$$.fragment,r),d(f.$$.fragment,r),d(j.$$.fragment,r),d(_.$$.fragment,r),d(M.$$.fragment,r),d(U.$$.fragment,r),d(P.$$.fragment,r),d(Y.$$.fragment,r),d(q.$$.fragment,r),d(y.$$.fragment,r),d(z.$$.fragment,r),d(D.$$.fragment,r),d(X.$$.fragment,r),d(Z.$$.fragment,r),d(B.$$.fragment,r),d(F.$$.fragment,r),d(ee.$$.fragment,r),d(G.$$.fragment,r),d(K.$$.fragment,r),we=!1},d(r){r&&(o(t),o($),o(a),o(I),o(x),o(k),o(A),o(L),o(Q),o($e),o(ue),o(ae),o(oe),o(pe),o(fe),o(le),o(me),o(ce),o(ie),o(_e),o(ge)),b(e,r),b(s,r),b(n,r),b(l,r),b(f,r),b(j,r),b(_,r),b(M,r),b(U,r),b(P,r),b(Y,r),b(q,r),b(y,r),b(z,r),b(D,r),b(X,r),b(Z,r),b(B,r),b(F,r),b(ee,r),b(G,r),b(K,r)}}}function Cn(u){let e,t;const s=[u[0],Fe];let $={$$slots:{default:[Nn]},$$scope:{ctx:u}};for(let n=0;n<s.length;n+=1)$=xe($,s[n]);return e=new Qe({props:$}),{c(){g(e.$$.fragment)},l(n){w(e.$$.fragment,n)},m(n,a){v(e,n,a),t=!0},p(n,[a]){const l=a&1?Le(s,[a&1&&Ze(n[0]),a&0&&Ze(Fe)]):{};a&2&&(l.$$scope={dirty:a,ctx:n}),e.$set(l)},i(n){t||(h(e.$$.fragment,n),t=!0)},o(n){d(e.$$.fragment,n),t=!1},d(n){b(e,n)}}}const Fe={title:"Intro to Svelte store",author:"henrikvilhelmberglund",authorlink:"github.com/henrikvilhelmberglund/",date:"2023-02-12T00:00:00.000Z",layout:"notes"};function Jn(u,e,t){return u.$$set=s=>{t(0,e=xe(xe({},e),Xe(s)))},e=Xe(e),[e]}class Bn extends V{constructor(e){super(),E(this,e,Jn,Cn,H,{})}}export{Bn as default,Fe as metadata};
