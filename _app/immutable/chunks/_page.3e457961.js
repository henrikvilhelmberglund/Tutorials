import{s as _e,C as x,D as re,a as k,c as A,i as a,d as r,l as i,m as g}from"./scheduler.a7cd560e.js";import{S as ie,i as ge,b as d,d as b,m as h,a as v,t as S,e as C}from"./index.396264e7.js";import{g as we,a as pe}from"./HR.svelte_svelte_type_style_lang.8355a705.js";import{M as de,P as W}from"./mdsvex-layout-notes.4b2b7ac6.js";import be from"./Count.7b498fa4.js";import he from"./Double.77bbdd95.js";import ve from"./DoubleFixed.a550dc26.js";import Se from"./DoubleConsole.ef2ab366.js";import Ce from"./DoubleConsole2.e1e5c2a9.js";import{H as De}from"./H3.2217b794.js";import{S as I}from"./Strong.097578ae.js";import{C as E}from"./Code.64283003.js";function Te(u){let t;return{c(){t=i("Let's say we have a Count component that shows a doubled value:")},l(e){t=g(e,"Let's say we have a Count component that shows a doubled value:")},m(e,o){a(e,t,o)},d(e){e&&r(t)}}}function ke(u){let t;return{c(){t=i("count * 2")},l(e){t=g(e,"count * 2")},m(e,o){a(e,t,o)},d(e){e&&r(t)}}}function Ae(u){let t;return{c(){t=i("let double = count * 2;")},l(e){t=g(e,"let double = count * 2;")},m(e,o){a(e,t,o)},d(e){e&&r(t)}}}function Ie(u){let t,e,o,l,s,m;return e=new I({props:{$$slots:{default:[ke]},$$scope:{ctx:u}}}),l=new I({props:{$$slots:{default:[Ae]},$$scope:{ctx:u}}}),{c(){t=i("This may be fine in simpler components but if we're using "),d(e.$$.fragment),o=i(" in a lot of places we might want to have a variable "),d(l.$$.fragment),s=i(" instead.")},l($){t=g($,"This may be fine in simpler components but if we're using "),b(e.$$.fragment,$),o=g($," in a lot of places we might want to have a variable "),b(l.$$.fragment,$),s=g($," instead.")},m($,p){a($,t,p),h(e,$,p),a($,o,p),h(l,$,p),a($,s,p),m=!0},p($,p){const f={};p&2&&(f.$$scope={dirty:p,ctx:$}),e.$set(f);const w={};p&2&&(w.$$scope={dirty:p,ctx:$}),l.$set(w)},i($){m||(v(e.$$.fragment,$),v(l.$$.fragment,$),m=!0)},o($){S(e.$$.fragment,$),S(l.$$.fragment,$),m=!1},d($){$&&(r(t),r(o),r(s)),C(e,$),C(l,$)}}}function Me(u){let t;return{c(){t=i("double")},l(e){t=g(e,"double")},m(e,o){a(e,t,o)},d(e){e&&r(t)}}}function We(u){let t;return{c(){t=i("once when the component loads")},l(e){t=g(e,"once when the component loads")},m(e,o){a(e,t,o)},d(e){e&&r(t)}}}function He(u){let t;return{c(){t=i("double")},l(e){t=g(e,"double")},m(e,o){a(e,t,o)},d(e){e&&r(t)}}}function Oe(u){let t;return{c(){t=i("reactive declaration")},l(e){t=g(e,"reactive declaration")},m(e,o){a(e,t,o)},d(e){e&&r(t)}}}function je(u){let t,e,o,l,s,m,$,p,f,w;return e=new E({props:{$$slots:{default:[Me]},$$scope:{ctx:u}}}),l=new I({props:{$$slots:{default:[We]},$$scope:{ctx:u}}}),m=new E({props:{$$slots:{default:[He]},$$scope:{ctx:u}}}),p=new I({props:{$$slots:{default:[Oe]},$$scope:{ctx:u}}}),{c(){t=i("We can see we have a problem though. The variable "),d(e.$$.fragment),o=i(" does not update because we're not updating it in the functions so it is only assigned to "),d(l.$$.fragment),s=i(". Instead of adding a statement to update "),d(m.$$.fragment),$=i(" in all of the functions we can use a "),d(p.$$.fragment),f=i(".")},l(_){t=g(_,"We can see we have a problem though. The variable "),b(e.$$.fragment,_),o=g(_," does not update because we're not updating it in the functions so it is only assigned to "),b(l.$$.fragment,_),s=g(_,". Instead of adding a statement to update "),b(m.$$.fragment,_),$=g(_," in all of the functions we can use a "),b(p.$$.fragment,_),f=g(_,".")},m(_,D){a(_,t,D),h(e,_,D),a(_,o,D),h(l,_,D),a(_,s,D),h(m,_,D),a(_,$,D),h(p,_,D),a(_,f,D),w=!0},p(_,D){const T={};D&2&&(T.$$scope={dirty:D,ctx:_}),e.$set(T);const q={};D&2&&(q.$$scope={dirty:D,ctx:_}),l.$set(q);const M={};D&2&&(M.$$scope={dirty:D,ctx:_}),m.$set(M);const Z={};D&2&&(Z.$$scope={dirty:D,ctx:_}),p.$set(Z)},i(_){w||(v(e.$$.fragment,_),v(l.$$.fragment,_),v(m.$$.fragment,_),v(p.$$.fragment,_),w=!0)},o(_){S(e.$$.fragment,_),S(l.$$.fragment,_),S(m.$$.fragment,_),S(p.$$.fragment,_),w=!1},d(_){_&&(r(t),r(o),r(s),r($),r(f)),C(e,_),C(l,_),C(m,_),C(p,_)}}}function Fe(u){let t;return{c(){t=i("let double = count * 2")},l(e){t=g(e,"let double = count * 2")},m(e,o){a(e,t,o)},d(e){e&&r(t)}}}function Re(u){let t;return{c(){t=i("$: double = count * 2")},l(e){t=g(e,"$: double = count * 2")},m(e,o){a(e,t,o)},d(e){e&&r(t)}}}function Le(u){let t,e,o,l,s,m;return e=new I({props:{$$slots:{default:[Fe]},$$scope:{ctx:u}}}),l=new I({props:{$$slots:{default:[Re]},$$scope:{ctx:u}}}),{c(){t=i("To do that we simply replace "),d(e.$$.fragment),o=i(" with "),d(l.$$.fragment),s=i(".")},l($){t=g($,"To do that we simply replace "),b(e.$$.fragment,$),o=g($," with "),b(l.$$.fragment,$),s=g($,".")},m($,p){a($,t,p),h(e,$,p),a($,o,p),h(l,$,p),a($,s,p),m=!0},p($,p){const f={};p&2&&(f.$$scope={dirty:p,ctx:$}),e.$set(f);const w={};p&2&&(w.$$scope={dirty:p,ctx:$}),l.$set(w)},i($){m||(v(e.$$.fragment,$),v(l.$$.fragment,$),m=!0)},o($){S(e.$$.fragment,$),S(l.$$.fragment,$),m=!1},d($){$&&(r(t),r(o),r(s)),C(e,$),C(l,$)}}}function Pe(u){let t;return{c(){t=i("when variables to the right of = are changed, rerun this code")},l(e){t=g(e,"when variables to the right of = are changed, rerun this code")},m(e,o){a(e,t,o)},d(e){e&&r(t)}}}function qe(u){let t,e,o,l;return e=new I({props:{$$slots:{default:[Pe]},$$scope:{ctx:u}}}),{c(){t=i("This is a special Svelte syntax that means "),d(e.$$.fragment),o=i(".")},l(s){t=g(s,"This is a special Svelte syntax that means "),b(e.$$.fragment,s),o=g(s,".")},m(s,m){a(s,t,m),h(e,s,m),a(s,o,m),l=!0},p(s,m){const $={};m&2&&($.$$scope={dirty:m,ctx:s}),e.$set($)},i(s){l||(v(e.$$.fragment,s),l=!0)},o(s){S(e.$$.fragment,s),l=!1},d(s){s&&(r(t),r(o)),C(e,s)}}}function Ze(u){let t;return{c(){t=i("count")},l(e){t=g(e,"count")},m(e,o){a(e,t,o)},d(e){e&&r(t)}}}function ze(u){let t;return{c(){t=i("count")},l(e){t=g(e,"count")},m(e,o){a(e,t,o)},d(e){e&&r(t)}}}function Be(u){let t;return{c(){t=i("$: double = count * 2")},l(e){t=g(e,"$: double = count * 2")},m(e,o){a(e,t,o)},d(e){e&&r(t)}}}function Ee(u){let t,e,o,l,s,m,$,p;return e=new E({props:{$$slots:{default:[Ze]},$$scope:{ctx:u}}}),l=new E({props:{$$slots:{default:[ze]},$$scope:{ctx:u}}}),m=new I({props:{$$slots:{default:[Be]},$$scope:{ctx:u}}}),{c(){t=i("When we click the buttons "),d(e.$$.fragment),o=i(" is changed. Since "),d(l.$$.fragment),s=i(" was changed, "),d(m.$$.fragment),$=i(" will rerun so we get the correct value even though we didn't update the double value in the functions.")},l(f){t=g(f,"When we click the buttons "),b(e.$$.fragment,f),o=g(f," is changed. Since "),b(l.$$.fragment,f),s=g(f," was changed, "),b(m.$$.fragment,f),$=g(f," will rerun so we get the correct value even though we didn't update the double value in the functions.")},m(f,w){a(f,t,w),h(e,f,w),a(f,o,w),h(l,f,w),a(f,s,w),h(m,f,w),a(f,$,w),p=!0},p(f,w){const _={};w&2&&(_.$$scope={dirty:w,ctx:f}),e.$set(_);const D={};w&2&&(D.$$scope={dirty:w,ctx:f}),l.$set(D);const T={};w&2&&(T.$$scope={dirty:w,ctx:f}),m.$set(T)},i(f){p||(v(e.$$.fragment,f),v(l.$$.fragment,f),v(m.$$.fragment,f),p=!0)},o(f){S(e.$$.fragment,f),S(l.$$.fragment,f),S(m.$$.fragment,f),p=!1},d(f){f&&(r(t),r(o),r(s),r($)),C(e,f),C(l,f),C(m,f)}}}function Ge(u){let t;return{c(){t=i("Reactive statements")},l(e){t=g(e,"Reactive statements")},m(e,o){a(e,t,o)},d(e){e&&r(t)}}}function Je(u){let t;return{c(){t=i("reactive statements")},l(e){t=g(e,"reactive statements")},m(e,o){a(e,t,o)},d(e){e&&r(t)}}}function Ke(u){let t;return{c(){t=i("count")},l(e){t=g(e,"count")},m(e,o){a(e,t,o)},d(e){e&&r(t)}}}function Ne(u){let t;return{c(){t=i("$: console.log(count);")},l(e){t=g(e,"$: console.log(count);")},m(e,o){a(e,t,o)},d(e){e&&r(t)}}}function Qe(u){let t,e,o,l,s,m,$,p;return e=new I({props:{$$slots:{default:[Je]},$$scope:{ctx:u}}}),l=new E({props:{$$slots:{default:[Ke]},$$scope:{ctx:u}}}),m=new I({props:{$$slots:{default:[Ne]},$$scope:{ctx:u}}}),{c(){t=i("We can also have "),d(e.$$.fragment),o=i(". For example we can log "),d(l.$$.fragment),s=i(" whenever it changes with "),d(m.$$.fragment),$=i(" which could be useful for debugging.")},l(f){t=g(f,"We can also have "),b(e.$$.fragment,f),o=g(f,". For example we can log "),b(l.$$.fragment,f),s=g(f," whenever it changes with "),b(m.$$.fragment,f),$=g(f," which could be useful for debugging.")},m(f,w){a(f,t,w),h(e,f,w),a(f,o,w),h(l,f,w),a(f,s,w),h(m,f,w),a(f,$,w),p=!0},p(f,w){const _={};w&2&&(_.$$scope={dirty:w,ctx:f}),e.$set(_);const D={};w&2&&(D.$$scope={dirty:w,ctx:f}),l.$set(D);const T={};w&2&&(T.$$scope={dirty:w,ctx:f}),m.$set(T)},i(f){p||(v(e.$$.fragment,f),v(l.$$.fragment,f),v(m.$$.fragment,f),p=!0)},o(f){S(e.$$.fragment,f),S(l.$$.fragment,f),S(m.$$.fragment,f),p=!1},d(f){f&&(r(t),r(o),r(s),r($)),C(e,f),C(l,f),C(m,f)}}}function Ue(u){let t;return{c(){t=i("variable it depends on (its dependency) is changed")},l(e){t=g(e,"variable it depends on (its dependency) is changed")},m(e,o){a(e,t,o)},d(e){e&&r(t)}}}function Ve(u){let t;return{c(){t=i("count")},l(e){t=g(e,"count")},m(e,o){a(e,t,o)},d(e){e&&r(t)}}}function Xe(u){let t,e,o,l,s,m;return e=new I({props:{$$slots:{default:[Ue]},$$scope:{ctx:u}}}),l=new I({props:{$$slots:{default:[Ve]},$$scope:{ctx:u}}}),{c(){t=i("As before the statement will be reevaluated whenever the "),d(e.$$.fragment),o=i(". In this case it is "),d(l.$$.fragment),s=i(" which changes when we click the buttons.")},l($){t=g($,"As before the statement will be reevaluated whenever the "),b(e.$$.fragment,$),o=g($,". In this case it is "),b(l.$$.fragment,$),s=g($," which changes when we click the buttons.")},m($,p){a($,t,p),h(e,$,p),a($,o,p),h(l,$,p),a($,s,p),m=!0},p($,p){const f={};p&2&&(f.$$scope={dirty:p,ctx:$}),e.$set(f);const w={};p&2&&(w.$$scope={dirty:p,ctx:$}),l.$set(w)},i($){m||(v(e.$$.fragment,$),v(l.$$.fragment,$),m=!0)},o($){S(e.$$.fragment,$),S(l.$$.fragment,$),m=!1},d($){$&&(r(t),r(o),r(s)),C(e,$),C(l,$)}}}function Ye(u){let t;return{c(){t=i("asynchronously")},l(e){t=g(e,"asynchronously")},m(e,o){a(e,t,o)},d(e){e&&r(t)}}}function xe(u){let t,e,o,l;return e=new I({props:{$$slots:{default:[Ye]},$$scope:{ctx:u}}}),{c(){t=i("A thing to note is that this does not happen immediately but instead "),d(e.$$.fragment),o=i(".")},l(s){t=g(s,"A thing to note is that this does not happen immediately but instead "),b(e.$$.fragment,s),o=g(s,".")},m(s,m){a(s,t,m),h(e,s,m),a(s,o,m),l=!0},p(s,m){const $={};m&2&&($.$$scope={dirty:m,ctx:s}),e.$set($)},i(s){l||(v(e.$$.fragment,s),l=!0)},o(s){S(e.$$.fragment,s),l=!1},d(s){s&&(r(t),r(o)),C(e,s)}}}function ye(u){let t;return{c(){t=i("just before Svelte updates the DOM")},l(e){t=g(e,"just before Svelte updates the DOM")},m(e,o){a(e,t,o)},d(e){e&&r(t)}}}function et(u){let t,e,o,l;return e=new I({props:{$$slots:{default:[ye]},$$scope:{ctx:u}}}),{c(){t=i("It does though happen "),d(e.$$.fragment),o=i(" (so the value in the DOM is always up to date).")},l(s){t=g(s,"It does though happen "),b(e.$$.fragment,s),o=g(s," (so the value in the DOM is always up to date).")},m(s,m){a(s,t,m),h(e,s,m),a(s,o,m),l=!0},p(s,m){const $={};m&2&&($.$$scope={dirty:m,ctx:s}),e.$set($)},i(s){l||(v(e.$$.fragment,s),l=!0)},o(s){S(e.$$.fragment,s),l=!1},d(s){s&&(r(t),r(o)),C(e,s)}}}function tt(u){let t;return{c(){t=i("they will be automatically reordered")},l(e){t=g(e,"they will be automatically reordered")},m(e,o){a(e,t,o)},d(e){e&&r(t)}}}function nt(u){let t;return{c(){t=i("top level")},l(e){t=g(e,"top level")},m(e,o){a(e,t,o)},d(e){e&&r(t)}}}function $t(u){let t,e,o,l,s,m;return e=new I({props:{$$slots:{default:[tt]},$$scope:{ctx:u}}}),l=new I({props:{$$slots:{default:[nt]},$$scope:{ctx:u}}}),{c(){t=i("A final thing to note is that the order of reactive declarations doesn't matter since "),d(e.$$.fragment),o=i(" by Svelte. However they must be declared in the "),d(l.$$.fragment),s=i(" (so not in functions).")},l($){t=g($,"A final thing to note is that the order of reactive declarations doesn't matter since "),b(e.$$.fragment,$),o=g($," by Svelte. However they must be declared in the "),b(l.$$.fragment,$),s=g($," (so not in functions).")},m($,p){a($,t,p),h(e,$,p),a($,o,p),h(l,$,p),a($,s,p),m=!0},p($,p){const f={};p&2&&(f.$$scope={dirty:p,ctx:$}),e.$set(f);const w={};p&2&&(w.$$scope={dirty:p,ctx:$}),l.$set(w)},i($){m||(v(e.$$.fragment,$),v(l.$$.fragment,$),m=!0)},o($){S(e.$$.fragment,$),S(l.$$.fragment,$),m=!1},d($){$&&(r(t),r(o),r(s)),C(e,$),C(l,$)}}}function st(u){let t,e,o,l,s,m,$,p,f,w,_,D,T,q,M,Z,H,G,O,J,j,K,z,N,F,Q,R,U,B,V,L,X,P,Y;return t=new W({props:{$$slots:{default:[Te]},$$scope:{ctx:u}}}),o=new be({}),s=new W({props:{$$slots:{default:[Ie]},$$scope:{ctx:u}}}),$=new he({}),f=new W({props:{$$slots:{default:[je]},$$scope:{ctx:u}}}),_=new W({props:{$$slots:{default:[Le]},$$scope:{ctx:u}}}),T=new ve({}),M=new W({props:{$$slots:{default:[qe]},$$scope:{ctx:u}}}),H=new W({props:{$$slots:{default:[Ee]},$$scope:{ctx:u}}}),O=new De({props:{$$slots:{default:[Ge]},$$scope:{ctx:u}}}),j=new W({props:{$$slots:{default:[Qe]},$$scope:{ctx:u}}}),z=new Se({}),F=new W({props:{$$slots:{default:[Xe]},$$scope:{ctx:u}}}),R=new W({props:{$$slots:{default:[xe]},$$scope:{ctx:u}}}),B=new Ce({}),L=new W({props:{$$slots:{default:[et]},$$scope:{ctx:u}}}),P=new W({props:{$$slots:{default:[$t]},$$scope:{ctx:u}}}),{c(){d(t.$$.fragment),e=k(),d(o.$$.fragment),l=k(),d(s.$$.fragment),m=k(),d($.$$.fragment),p=k(),d(f.$$.fragment),w=k(),d(_.$$.fragment),D=k(),d(T.$$.fragment),q=k(),d(M.$$.fragment),Z=k(),d(H.$$.fragment),G=k(),d(O.$$.fragment),J=k(),d(j.$$.fragment),K=k(),d(z.$$.fragment),N=k(),d(F.$$.fragment),Q=k(),d(R.$$.fragment),U=k(),d(B.$$.fragment),V=k(),d(L.$$.fragment),X=k(),d(P.$$.fragment)},l(n){b(t.$$.fragment,n),e=A(n),b(o.$$.fragment,n),l=A(n),b(s.$$.fragment,n),m=A(n),b($.$$.fragment,n),p=A(n),b(f.$$.fragment,n),w=A(n),b(_.$$.fragment,n),D=A(n),b(T.$$.fragment,n),q=A(n),b(M.$$.fragment,n),Z=A(n),b(H.$$.fragment,n),G=A(n),b(O.$$.fragment,n),J=A(n),b(j.$$.fragment,n),K=A(n),b(z.$$.fragment,n),N=A(n),b(F.$$.fragment,n),Q=A(n),b(R.$$.fragment,n),U=A(n),b(B.$$.fragment,n),V=A(n),b(L.$$.fragment,n),X=A(n),b(P.$$.fragment,n)},m(n,c){h(t,n,c),a(n,e,c),h(o,n,c),a(n,l,c),h(s,n,c),a(n,m,c),h($,n,c),a(n,p,c),h(f,n,c),a(n,w,c),h(_,n,c),a(n,D,c),h(T,n,c),a(n,q,c),h(M,n,c),a(n,Z,c),h(H,n,c),a(n,G,c),h(O,n,c),a(n,J,c),h(j,n,c),a(n,K,c),h(z,n,c),a(n,N,c),h(F,n,c),a(n,Q,c),h(R,n,c),a(n,U,c),h(B,n,c),a(n,V,c),h(L,n,c),a(n,X,c),h(P,n,c),Y=!0},p(n,c){const y={};c&2&&(y.$$scope={dirty:c,ctx:n}),t.$set(y);const ee={};c&2&&(ee.$$scope={dirty:c,ctx:n}),s.$set(ee);const te={};c&2&&(te.$$scope={dirty:c,ctx:n}),f.$set(te);const ne={};c&2&&(ne.$$scope={dirty:c,ctx:n}),_.$set(ne);const $e={};c&2&&($e.$$scope={dirty:c,ctx:n}),M.$set($e);const se={};c&2&&(se.$$scope={dirty:c,ctx:n}),H.$set(se);const oe={};c&2&&(oe.$$scope={dirty:c,ctx:n}),O.$set(oe);const fe={};c&2&&(fe.$$scope={dirty:c,ctx:n}),j.$set(fe);const le={};c&2&&(le.$$scope={dirty:c,ctx:n}),F.$set(le);const me={};c&2&&(me.$$scope={dirty:c,ctx:n}),R.$set(me);const ue={};c&2&&(ue.$$scope={dirty:c,ctx:n}),L.$set(ue);const ae={};c&2&&(ae.$$scope={dirty:c,ctx:n}),P.$set(ae)},i(n){Y||(v(t.$$.fragment,n),v(o.$$.fragment,n),v(s.$$.fragment,n),v($.$$.fragment,n),v(f.$$.fragment,n),v(_.$$.fragment,n),v(T.$$.fragment,n),v(M.$$.fragment,n),v(H.$$.fragment,n),v(O.$$.fragment,n),v(j.$$.fragment,n),v(z.$$.fragment,n),v(F.$$.fragment,n),v(R.$$.fragment,n),v(B.$$.fragment,n),v(L.$$.fragment,n),v(P.$$.fragment,n),Y=!0)},o(n){S(t.$$.fragment,n),S(o.$$.fragment,n),S(s.$$.fragment,n),S($.$$.fragment,n),S(f.$$.fragment,n),S(_.$$.fragment,n),S(T.$$.fragment,n),S(M.$$.fragment,n),S(H.$$.fragment,n),S(O.$$.fragment,n),S(j.$$.fragment,n),S(z.$$.fragment,n),S(F.$$.fragment,n),S(R.$$.fragment,n),S(B.$$.fragment,n),S(L.$$.fragment,n),S(P.$$.fragment,n),Y=!1},d(n){n&&(r(e),r(l),r(m),r(p),r(w),r(D),r(q),r(Z),r(G),r(J),r(K),r(N),r(Q),r(U),r(V),r(X)),C(t,n),C(o,n),C(s,n),C($,n),C(f,n),C(_,n),C(T,n),C(M,n),C(H,n),C(O,n),C(j,n),C(z,n),C(F,n),C(R,n),C(B,n),C(L,n),C(P,n)}}}function ot(u){let t,e;const o=[u[0],ce];let l={$$slots:{default:[st]},$$scope:{ctx:u}};for(let s=0;s<o.length;s+=1)l=x(l,o[s]);return t=new de({props:l}),{c(){d(t.$$.fragment)},l(s){b(t.$$.fragment,s)},m(s,m){h(t,s,m),e=!0},p(s,[m]){const $=m&1?we(o,[m&1&&pe(s[0]),m&0&&pe(ce)]):{};m&2&&($.$$scope={dirty:m,ctx:s}),t.$set($)},i(s){e||(v(t.$$.fragment,s),e=!0)},o(s){S(t.$$.fragment,s),e=!1},d(s){C(t,s)}}}const ce={title:"Reactive declarations and statements",author:"henrikvilhelmberglund",authorlink:"github.com/henrikvilhelmberglund/",date:"2023-02-02T00:00:00.000Z",layout:"notes"};function ft(u,t,e){return u.$$set=o=>{e(0,t=x(x({},t),re(o)))},t=re(t),[t]}class bt extends ie{constructor(t){super(),ge(this,t,ft,ot,_e,{})}}export{bt as default,ce as metadata};
