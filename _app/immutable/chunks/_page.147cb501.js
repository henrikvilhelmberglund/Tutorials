import{s as R,f as S,g as N,h as P,d as p,j as E,i as u,z as A,B as I,l as h,m as d,v as D,n as U,a as j,c as z,C,D as F}from"./scheduler.a7cd560e.js";import{S as W,i as q,a as g,g as ee,c as te,t as b,b as v,d as w,m as k,e as y}from"./index.396264e7.js";import{g as se,a as G}from"./HR.svelte_svelte_type_style_lang.8355a705.js";import{M as le,P as B}from"./mdsvex-layout-notes.4b2b7ac6.js";import{S as J}from"./ShowMany.db7be1f3.js";import{e as x}from"./each.32d06572.js";import{S as M}from"./Strong.097578ae.js";function K(c,e,s){const t=c.slice();return t[1]=e[s],t}function L(c){let e,s=c[1]+"",t;return{c(){e=S("span"),t=h(s),this.h()},l(n){e=N(n,"SPAN",{class:!0});var r=P(e);t=d(r,s),r.forEach(p),this.h()},h(){E(e,"class","spu-wcsi3d")},m(n,r){u(n,e,r),D(e,t)},p(n,r){r&1&&s!==(s=n[1]+"")&&U(t,s)},d(n){n&&p(e)}}}function re(c){let e,s=x(c[0]),t=[];for(let n=0;n<s.length;n+=1)t[n]=L(K(c,s,n));return{c(){e=S("span");for(let n=0;n<t.length;n+=1)t[n].c();this.h()},l(n){e=N(n,"SPAN",{class:!0});var r=P(e);for(let l=0;l<t.length;l+=1)t[l].l(r);r.forEach(p),this.h()},h(){E(e,"class","spu-1v3268")},m(n,r){u(n,e,r);for(let l=0;l<t.length;l+=1)t[l]&&t[l].m(e,null)},p(n,[r]){if(r&1){s=x(n[0]);let l;for(l=0;l<s.length;l+=1){const i=K(n,s,l);t[l]?t[l].p(i,r):(t[l]=L(i),t[l].c(),t[l].m(e,null))}for(;l<t.length;l+=1)t[l].d(1);t.length=s.length}},i:A,o:A,d(n){n&&p(e),I(t,n)}}}function ae(c,e,s){let{data:t=[1,2,3,4,5]}=e;return c.$$set=n=>{"data"in n&&s(0,t=n.data)},[t]}class oe extends W{constructor(e){super(),q(this,e,ae,re,R,{data:0})}}const ce=`<script>\r
	export let data = [1, 2, 3, 4, 5];\r
<\/script>\r
\r
<span class="m-1 inline-block border border-solid border-blue-500">\r
	{#each data as item}\r
		<span class="m-1 inline-block border border-solid border-red-500">{item}</span>\r
	{/each}\r
</span>\r
\r
<style>\r
</style>\r
`;function O(c,e,s){const t=c.slice();return t[1]=e[s],t}function ie(c){let e=c[1]+"",s;return{c(){s=h(e)},l(t){s=d(t,e)},m(t,n){u(t,s,n)},p(t,n){n&1&&e!==(e=t[1]+"")&&U(s,e)},i:A,o:A,d(t){t&&p(s)}}}function fe(c){let e,s;return e=new ne({props:{data:c[1]}}),{c(){v(e.$$.fragment)},l(t){w(e.$$.fragment,t)},m(t,n){k(e,t,n),s=!0},p(t,n){const r={};n&1&&(r.data=t[1]),e.$set(r)},i(t){s||(g(e.$$.fragment,t),s=!0)},o(t){b(e.$$.fragment,t),s=!1},d(t){y(e,t)}}}function Q(c){let e,s,t,n,r,l;const i=[fe,ie],f=[];function m(_,a){return a&1&&(s=null),s==null&&(s=!!Array.isArray(_[1])),s?0:1}return t=m(c,-1),n=f[t]=i[t](c),{c(){e=S("span"),n.c(),r=j(),this.h()},l(_){e=N(_,"SPAN",{class:!0});var a=P(e);n.l(a),r=z(a),a.forEach(p),this.h()},h(){E(e,"class","spu-ye7vjr")},m(_,a){u(_,e,a),f[t].m(e,null),D(e,r),l=!0},p(_,a){let o=t;t=m(_,a),t===o?f[t].p(_,a):(ee(),b(f[o],1,1,()=>{f[o]=null}),te(),n=f[t],n?n.p(_,a):(n=f[t]=i[t](_),n.c()),g(n,1),n.m(e,r))},i(_){l||(g(n),l=!0)},o(_){b(n),l=!1},d(_){_&&p(e),f[t].d()}}}function pe(c){let e,s,t=x(c[0]),n=[];for(let l=0;l<t.length;l+=1)n[l]=Q(O(c,t,l));const r=l=>b(n[l],1,1,()=>{n[l]=null});return{c(){e=S("span");for(let l=0;l<n.length;l+=1)n[l].c();this.h()},l(l){e=N(l,"SPAN",{class:!0});var i=P(e);for(let f=0;f<n.length;f+=1)n[f].l(i);i.forEach(p),this.h()},h(){E(e,"class","spu-oo3h14")},m(l,i){u(l,e,i);for(let f=0;f<n.length;f+=1)n[f]&&n[f].m(e,null);s=!0},p(l,[i]){if(i&1){t=x(l[0]);let f;for(f=0;f<t.length;f+=1){const m=O(l,t,f);n[f]?(n[f].p(m,i),g(n[f],1)):(n[f]=Q(m),n[f].c(),g(n[f],1),n[f].m(e,null))}for(ee(),f=t.length;f<n.length;f+=1)r(f);te()}},i(l){if(!s){for(let i=0;i<t.length;i+=1)g(n[i]);s=!0}},o(l){n=n.filter(Boolean);for(let i=0;i<n.length;i+=1)b(n[i]);s=!1},d(l){l&&p(e),I(n,l)}}}function ue(c,e,s){let{data:t=[1,[2,[3],4],5]}=e;return c.$$set=n=>{"data"in n&&s(0,t=n.data)},[t]}class ne extends W{constructor(e){super(),q(this,e,ue,pe,R,{data:0})}}const _e=`<script>\r
	export let data = [1, [2, [3], 4], 5];\r
<\/script>\r
\r
<span class="m-1 inline-block border border-solid border-blue-500">\r
	{#each data as item}\r
		<span class="m-1 inline-block border border-solid border-red-500">\r
			{#if Array.isArray(item)}\r
				<svelte:self data={item} />\r
			{:else}\r
				{item}\r
			{/if}\r
		</span>\r
	{/each}\r
</span>\r
\r
<style>\r
</style>\r
`;function V(c,e,s){const t=c.slice();return t[1]=e[s],t}function X(c){let e,s=c[1]+"",t;return{c(){e=S("span"),t=h(s),this.h()},l(n){e=N(n,"SPAN",{class:!0});var r=P(e);t=d(r,s),r.forEach(p),this.h()},h(){E(e,"class","spu-q9uv73")},m(n,r){u(n,e,r),D(e,t)},p(n,r){r&1&&s!==(s=n[1]+"")&&U(t,s)},d(n){n&&p(e)}}}function me(c){let e,s=x(c[0]),t=[];for(let n=0;n<s.length;n+=1)t[n]=X(V(c,s,n));return{c(){e=S("span");for(let n=0;n<t.length;n+=1)t[n].c();this.h()},l(n){e=N(n,"SPAN",{class:!0});var r=P(e);for(let l=0;l<t.length;l+=1)t[l].l(r);r.forEach(p),this.h()},h(){E(e,"class","spu-7nofbk")},m(n,r){u(n,e,r);for(let l=0;l<t.length;l+=1)t[l]&&t[l].m(e,null)},p(n,[r]){if(r&1){s=x(n[0]);let l;for(l=0;l<s.length;l+=1){const i=V(n,s,l);t[l]?t[l].p(i,r):(t[l]=X(i),t[l].c(),t[l].m(e,null))}for(;l<t.length;l+=1)t[l].d(1);t.length=s.length}},i:A,o:A,d(n){n&&p(e),I(t,n)}}}function $e(c,e,s){let{data:t=[1,[2,[3],4],5]}=e;return c.$$set=n=>{"data"in n&&s(0,t=n.data)},[t]}class he extends W{constructor(e){super(),q(this,e,$e,me,R,{data:0})}}const de=`<script>\r
	export let data = [1, [2, [3], 4], 5];\r
<\/script>\r
\r
<span class="m-1 inline-block border border-solid border-blue-500">\r
	{#each data as item}\r
		<span class="m-1 inline-block border border-solid border-red-500">{item}</span>\r
	{/each}\r
</span>\r
\r
<style>\r
</style>\r
`;function ge(c){let e;return{c(){e=h("Here we want to display a visualization of arrays.")},l(s){e=d(s,"Here we want to display a visualization of arrays.")},m(s,t){u(s,e,t)},d(s){s&&p(e)}}}function be(c){let e="<",s,t;return{c(){s=h(e),t=h("svelte:self>")},l(n){s=d(n,e),t=d(n,"svelte:self>")},m(n,r){u(n,s,r),u(n,t,r)},p:A,d(n){n&&(p(s),p(t))}}}function ve(c){let e,s,t,n;return s=new M({props:{$$slots:{default:[be]},$$scope:{ctx:c}}}),{c(){e=h("It works fine with a flat array, but what if it is nested? We can use "),v(s.$$.fragment),t=h(" for recursively displaying the component.")},l(r){e=d(r,"It works fine with a flat array, but what if it is nested? We can use "),w(s.$$.fragment,r),t=d(r," for recursively displaying the component.")},m(r,l){u(r,e,l),k(s,r,l),u(r,t,l),n=!0},p(r,l){const i={};l&2&&(i.$$scope={dirty:l,ctx:r}),s.$set(i)},i(r){n||(g(s.$$.fragment,r),n=!0)},o(r){b(s.$$.fragment,r),n=!1},d(r){r&&(p(e),p(t)),y(s,r)}}}function we(c){let e;return{c(){e=h("if blocks")},l(s){e=d(s,"if blocks")},m(s,t){u(s,e,t)},d(s){s&&p(e)}}}function ke(c){let e;return{c(){e=h("each blocks")},l(s){e=d(s,"each blocks")},m(s,t){u(s,e,t)},d(s){s&&p(e)}}}function ye(c){let e;return{c(){e=h("slots")},l(s){e=d(s,"slots")},m(s,t){u(s,e,t)},d(s){s&&p(e)}}}function Ae(c){let e,s="<",t,n,r,l,i,f,m,_,a;return r=new M({props:{$$slots:{default:[we]},$$scope:{ctx:c}}}),i=new M({props:{$$slots:{default:[ke]},$$scope:{ctx:c}}}),m=new M({props:{$$slots:{default:[ye]},$$scope:{ctx:c}}}),{c(){e=h("To prevent infinite loops "),t=h(s),n=h("svelte:self> can only be used within "),v(r.$$.fragment),l=h(", "),v(i.$$.fragment),f=h(" or in "),v(m.$$.fragment),_=h(".")},l(o){e=d(o,"To prevent infinite loops "),t=d(o,s),n=d(o,"svelte:self> can only be used within "),w(r.$$.fragment,o),l=d(o,", "),w(i.$$.fragment,o),f=d(o," or in "),w(m.$$.fragment,o),_=d(o,".")},m(o,$){u(o,e,$),u(o,t,$),u(o,n,$),k(r,o,$),u(o,l,$),k(i,o,$),u(o,f,$),k(m,o,$),u(o,_,$),a=!0},p(o,$){const H={};$&2&&(H.$$scope={dirty:$,ctx:o}),r.$set(H);const T={};$&2&&(T.$$scope={dirty:$,ctx:o}),i.$set(T);const Z={};$&2&&(Z.$$scope={dirty:$,ctx:o}),m.$set(Z)},i(o){a||(g(r.$$.fragment,o),g(i.$$.fragment,o),g(m.$$.fragment,o),a=!0)},o(o){b(r.$$.fragment,o),b(i.$$.fragment,o),b(m.$$.fragment,o),a=!1},d(o){o&&(p(e),p(t),p(n),p(l),p(f),p(_)),y(r,o),y(i,o),y(m,o)}}}function xe(c){let e,s,t,n,r,l,i,f,m,_;return e=new B({props:{$$slots:{default:[ge]},$$scope:{ctx:c}}}),t=new J({props:{name:[{name:"App",comp:oe,raw:ce,text:"This looks fine!"},{name:"Nested",comp:he,raw:de,text:"Uh oh, we broke it."}]}}),r=new B({props:{$$slots:{default:[ve]},$$scope:{ctx:c}}}),i=new J({props:{name:[{name:"App2",comp:ne,raw:_e,text:"Here we used the svelte:self element to recursively show the component again if the item was an array. We can also pass props to it. Here we pass in the data array."}]}}),m=new B({props:{$$slots:{default:[Ae]},$$scope:{ctx:c}}}),{c(){v(e.$$.fragment),s=j(),v(t.$$.fragment),n=j(),v(r.$$.fragment),l=j(),v(i.$$.fragment),f=j(),v(m.$$.fragment)},l(a){w(e.$$.fragment,a),s=z(a),w(t.$$.fragment,a),n=z(a),w(r.$$.fragment,a),l=z(a),w(i.$$.fragment,a),f=z(a),w(m.$$.fragment,a)},m(a,o){k(e,a,o),u(a,s,o),k(t,a,o),u(a,n,o),k(r,a,o),u(a,l,o),k(i,a,o),u(a,f,o),k(m,a,o),_=!0},p(a,o){const $={};o&2&&($.$$scope={dirty:o,ctx:a}),e.$set($);const H={};o&2&&(H.$$scope={dirty:o,ctx:a}),r.$set(H);const T={};o&2&&(T.$$scope={dirty:o,ctx:a}),m.$set(T)},i(a){_||(g(e.$$.fragment,a),g(t.$$.fragment,a),g(r.$$.fragment,a),g(i.$$.fragment,a),g(m.$$.fragment,a),_=!0)},o(a){b(e.$$.fragment,a),b(t.$$.fragment,a),b(r.$$.fragment,a),b(i.$$.fragment,a),b(m.$$.fragment,a),_=!1},d(a){a&&(p(s),p(n),p(l),p(f)),y(e,a),y(t,a),y(r,a),y(i,a),y(m,a)}}}function Se(c){let e,s;const t=[c[0],Y];let n={$$slots:{default:[xe]},$$scope:{ctx:c}};for(let r=0;r<t.length;r+=1)n=C(n,t[r]);return e=new le({props:n}),{c(){v(e.$$.fragment)},l(r){w(e.$$.fragment,r)},m(r,l){k(e,r,l),s=!0},p(r,[l]){const i=l&1?se(t,[l&1&&G(r[0]),l&0&&G(Y)]):{};l&2&&(i.$$scope={dirty:l,ctx:r}),e.$set(i)},i(r){s||(g(e.$$.fragment,r),s=!0)},o(r){b(e.$$.fragment,r),s=!1},d(r){y(e,r)}}}const Y={title:"<svelte:self>",author:"henrikvilhelmberglund",authorlink:"github.com/henrikvilhelmberglund/",date:"2023-04-28T00:00:00.000Z",layout:"notes"};function Ne(c,e,s){return c.$$set=t=>{s(0,e=C(C({},e),F(t)))},e=F(e),[e]}class Re extends W{constructor(e){super(),q(this,e,Ne,Se,R,{})}}export{Re as default,Y as metadata};
