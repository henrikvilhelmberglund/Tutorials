import{s as H,f as D,g as L,j as Y,i as m,X as et,z as B,d as p,l as c,h as y,m as _,v as J,n as nt,o as st,a as j,c as A,C as z,D as K}from"./scheduler.a7cd560e.js";import{S as W,i as q,b as w,d as b,m as v,a as d,t as h,e as k}from"./index.396264e7.js";import{g as rt,a as Q}from"./HR.svelte_svelte_type_style_lang.8355a705.js";import{M as ot,P as E}from"./mdsvex-layout-notes.4b2b7ac6.js";import{w as $t}from"./index.5e192797.js";import{S as at}from"./ShowMany.db7be1f3.js";import{S as I}from"./Strong.097578ae.js";let tt=$t("");function lt(a){let e,t,r;return{c(){e=D("input"),this.h()},l(o){e=L(o,"INPUT",{type:!0}),this.h()},h(){Y(e,"type","text")},m(o,n){m(o,e,n),t||(r=et(e,"input",a[0]),t=!0)},p:B,i:B,o:B,d(o){o&&p(e),t=!1,r()}}}function ft(a){return[t=>tt.set(t.currentTarget.value)]}class ut extends W{constructor(e){super(),q(this,e,ft,lt,H,{})}}function pt(a){let e,t,r;return{c(){e=D("h1"),t=c("value: "),r=c(a[0])},l(o){e=L(o,"H1",{});var n=y(e);t=_(n,"value: "),r=_(n,a[0]),n.forEach(p)},m(o,n){m(o,e,n),J(e,t),J(e,r)},p(o,[n]){n&1&&nt(r,o[0])},i:B,o:B,d(o){o&&p(e)}}}function mt(a,e,t){let r;return st(()=>tt.subscribe(o=>{t(0,r=o)})),[r]}class ct extends W{constructor(e){super(),q(this,e,mt,pt,H,{})}}function _t(a){let e,t,r,o;return e=new ut({}),r=new ct({}),{c(){w(e.$$.fragment),t=j(),w(r.$$.fragment)},l(n){b(e.$$.fragment,n),t=A(n),b(r.$$.fragment,n)},m(n,f){v(e,n,f),m(n,t,f),v(r,n,f),o=!0},p:B,i(n){o||(d(e.$$.fragment,n),d(r.$$.fragment,n),o=!0)},o(n){h(e.$$.fragment,n),h(r.$$.fragment,n),o=!1},d(n){n&&p(t),k(e,n),k(r,n)}}}class C extends W{constructor(e){super(),q(this,e,null,_t,H,{})}}const it=`<script>\r
	import Input from "./Input.svelte";\r
	import Output from "./Output.svelte";\r
<\/script>\r
\r
<Input />\r
<Output />\r
`,gt=`<script>\r
	import { valueStore } from "./data";\r
<\/script>\r
\r
<input on:input={(e) => valueStore.set(e.currentTarget.value)} type="text" />\r
`,wt=`<script>\r
	import { valueStore } from "./data";\r
	import { onMount } from "svelte";\r
\r
	let _value;\r
\r
	onMount(() => {\r
		return valueStore.subscribe((value) => {\r
			_value = value;\r
		});\r
	});\r
<\/script>\r
\r
<h1>value: {_value}</h1>\r
`,bt=`import { writable, readable } from "svelte/store";\r
\r
export let valueStore = writable("");\r
`;function vt(a){let e;return{c(){e=c("store functions")},l(t){e=_(t,"store functions")},m(t,r){m(t,e,r)},d(t){t&&p(e)}}}function dt(a){let e;return{c(){e=c("writable store")},l(t){e=_(t,"writable store")},m(t,r){m(t,e,r)},d(t){t&&p(e)}}}function ht(a){let e,t,r,o,n,f;return t=new I({props:{$$slots:{default:[vt]},$$scope:{ctx:a}}}),o=new I({props:{$$slots:{default:[dt]},$$scope:{ctx:a}}}),{c(){e=c("Svelte has a few built-in "),w(t.$$.fragment),r=c(", one of them being the "),w(o.$$.fragment),n=c(".")},l(s){e=_(s,"Svelte has a few built-in "),b(t.$$.fragment,s),r=_(s,", one of them being the "),b(o.$$.fragment,s),n=_(s,".")},m(s,u){m(s,e,u),v(t,s,u),m(s,r,u),v(o,s,u),m(s,n,u),f=!0},p(s,u){const S={};u&2&&(S.$$scope={dirty:u,ctx:s}),t.$set(S);const x={};u&2&&(x.$$scope={dirty:u,ctx:s}),o.$set(x)},i(s){f||(d(t.$$.fragment,s),d(o.$$.fragment,s),f=!0)},o(s){h(t.$$.fragment,s),h(o.$$.fragment,s),f=!1},d(s){s&&(p(e),p(r),p(n)),k(t,s),k(o,s)}}}function kt(a){let e;return{c(){e=c('importing them from "svelte/store"')},l(t){e=_(t,'importing them from "svelte/store"')},m(t,r){m(t,e,r)},d(t){t&&p(e)}}}function St(a){let e,t,r,o;return t=new I({props:{$$slots:{default:[kt]},$$scope:{ctx:a}}}),{c(){e=c("We use them by "),w(t.$$.fragment),r=c(" like this:")},l(n){e=_(n,"We use them by "),b(t.$$.fragment,n),r=_(n," like this:")},m(n,f){m(n,e,f),v(t,n,f),m(n,r,f),o=!0},p(n,f){const s={};f&2&&(s.$$scope={dirty:f,ctx:n}),t.$set(s)},i(n){o||(d(t.$$.fragment,n),o=!0)},o(n){h(t.$$.fragment,n),o=!1},d(n){n&&(p(e),p(r)),k(t,n)}}}function xt(a){let e;return{c(){e=c("writable")},l(t){e=_(t,"writable")},m(t,r){m(t,e,r)},d(t){t&&p(e)}}}function It(a){let e;return{c(){e=c("read")},l(t){e=_(t,"read")},m(t,r){m(t,e,r)},d(t){t&&p(e)}}}function Mt(a){let e;return{c(){e=c("write")},l(t){e=_(t,"write")},m(t,r){m(t,e,r)},d(t){t&&p(e)}}}function Tt(a){let e;return{c(){e=c("readable")},l(t){e=_(t,"readable")},m(t,r){m(t,e,r)},d(t){t&&p(e)}}}function Ot(a){let e;return{c(){e=c("read only")},l(t){e=_(t,"read only")},m(t,r){m(t,e,r)},d(t){t&&p(e)}}}function jt(a){let e,t,r,o,n,f,s,u,S,x,O;return e=new I({props:{$$slots:{default:[xt]},$$scope:{ctx:a}}}),r=new I({props:{$$slots:{default:[It]},$$scope:{ctx:a}}}),n=new I({props:{$$slots:{default:[Mt]},$$scope:{ctx:a}}}),s=new I({props:{$$slots:{default:[Tt]},$$scope:{ctx:a}}}),S=new I({props:{$$slots:{default:[Ot]},$$scope:{ctx:a}}}),{c(){w(e.$$.fragment),t=c(" is a store where we can both "),w(r.$$.fragment),o=c(" and "),w(n.$$.fragment),f=c(", and "),w(s.$$.fragment),u=c(" is a store that is "),w(S.$$.fragment),x=c(".")},l(l){b(e.$$.fragment,l),t=_(l," is a store where we can both "),b(r.$$.fragment,l),o=_(l," and "),b(n.$$.fragment,l),f=_(l,", and "),b(s.$$.fragment,l),u=_(l," is a store that is "),b(S.$$.fragment,l),x=_(l,".")},m(l,g){v(e,l,g),m(l,t,g),v(r,l,g),m(l,o,g),v(n,l,g),m(l,f,g),v(s,l,g),m(l,u,g),v(S,l,g),m(l,x,g),O=!0},p(l,g){const T={};g&2&&(T.$$scope={dirty:g,ctx:l}),e.$set(T);const R={};g&2&&(R.$$scope={dirty:g,ctx:l}),r.$set(R);const M={};g&2&&(M.$$scope={dirty:g,ctx:l}),n.$set(M);const P={};g&2&&(P.$$scope={dirty:g,ctx:l}),s.$set(P);const $={};g&2&&($.$$scope={dirty:g,ctx:l}),S.$set($)},i(l){O||(d(e.$$.fragment,l),d(r.$$.fragment,l),d(n.$$.fragment,l),d(s.$$.fragment,l),d(S.$$.fragment,l),O=!0)},o(l){h(e.$$.fragment,l),h(r.$$.fragment,l),h(n.$$.fragment,l),h(s.$$.fragment,l),h(S.$$.fragment,l),O=!1},d(l){l&&(p(t),p(o),p(f),p(u),p(x)),k(e,l),k(r,l),k(n,l),k(s,l),k(S,l)}}}function At(a){let e;return{c(){e=c("subscribe")},l(t){e=_(t,"subscribe")},m(t,r){m(t,e,r)},d(t){t&&p(e)}}}function Rt(a){let e;return{c(){e=c("subscribe to the store")},l(t){e=_(t,"subscribe to the store")},m(t,r){m(t,e,r)},d(t){t&&p(e)}}}function Pt(a){let e,t,r,o,n,f;return t=new I({props:{$$slots:{default:[At]},$$scope:{ctx:a}}}),o=new I({props:{$$slots:{default:[Rt]},$$scope:{ctx:a}}}),{c(){e=c("Both of these stores have a method called "),w(t.$$.fragment),r=c(" that allows you to "),w(o.$$.fragment),n=c(".")},l(s){e=_(s,"Both of these stores have a method called "),b(t.$$.fragment,s),r=_(s," that allows you to "),b(o.$$.fragment,s),n=_(s,".")},m(s,u){m(s,e,u),v(t,s,u),m(s,r,u),v(o,s,u),m(s,n,u),f=!0},p(s,u){const S={};u&2&&(S.$$scope={dirty:u,ctx:s}),t.$set(S);const x={};u&2&&(x.$$scope={dirty:u,ctx:s}),o.$set(x)},i(s){f||(d(t.$$.fragment,s),d(o.$$.fragment,s),f=!0)},o(s){h(t.$$.fragment,s),h(o.$$.fragment,s),f=!1},d(s){s&&(p(e),p(r),p(n)),k(t,s),k(o,s)}}}function Et(a){let e;return{c(){e=c("set")},l(t){e=_(t,"set")},m(t,r){m(t,e,r)},d(t){t&&p(e)}}}function Bt(a){let e;return{c(){e=c("set (and update) the value")},l(t){e=_(t,"set (and update) the value")},m(t,r){m(t,e,r)},d(t){t&&p(e)}}}function Ct(a){let e,t,r,o,n,f;return t=new I({props:{$$slots:{default:[Et]},$$scope:{ctx:a}}}),o=new I({props:{$$slots:{default:[Bt]},$$scope:{ctx:a}}}),{c(){e=c("The writable store has a method called "),w(t.$$.fragment),r=c(" that allows you to "),w(o.$$.fragment),n=c(".")},l(s){e=_(s,"The writable store has a method called "),b(t.$$.fragment,s),r=_(s," that allows you to "),b(o.$$.fragment,s),n=_(s,".")},m(s,u){m(s,e,u),v(t,s,u),m(s,r,u),v(o,s,u),m(s,n,u),f=!0},p(s,u){const S={};u&2&&(S.$$scope={dirty:u,ctx:s}),t.$set(S);const x={};u&2&&(x.$$scope={dirty:u,ctx:s}),o.$set(x)},i(s){f||(d(t.$$.fragment,s),d(o.$$.fragment,s),f=!0)},o(s){h(t.$$.fragment,s),h(o.$$.fragment,s),f=!1},d(s){s&&(p(e),p(r),p(n)),k(t,s),k(o,s)}}}function Ht(a){let e;return{c(){e=c("writable store")},l(t){e=_(t,"writable store")},m(t,r){m(t,e,r)},d(t){t&&p(e)}}}function Wt(a){let e,t,r,o;return t=new I({props:{$$slots:{default:[Ht]},$$scope:{ctx:a}}}),{c(){e=c("As you can see we could remove a lot of code by using the built in "),w(t.$$.fragment),r=c(" functionality.")},l(n){e=_(n,"As you can see we could remove a lot of code by using the built in "),b(t.$$.fragment,n),r=_(n," functionality.")},m(n,f){m(n,e,f),v(t,n,f),m(n,r,f),o=!0},p(n,f){const s={};f&2&&(s.$$scope={dirty:f,ctx:n}),t.$set(s)},i(n){o||(d(t.$$.fragment,n),o=!0)},o(n){h(t.$$.fragment,n),o=!1},d(n){n&&(p(e),p(r)),k(t,n)}}}function qt(a){let e,t,r,o,n,f='<code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span> writable<span class="token punctuation">,</span> readable <span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">"svelte/store"</span><span class="token punctuation">;</span></code>',s,u,S,x,O,l,g,T,R,M,P;return e=new E({props:{$$slots:{default:[ht]},$$scope:{ctx:a}}}),r=new E({props:{$$slots:{default:[St]},$$scope:{ctx:a}}}),u=new E({props:{$$slots:{default:[jt]},$$scope:{ctx:a}}}),x=new E({props:{$$slots:{default:[Pt]},$$scope:{ctx:a}}}),l=new E({props:{$$slots:{default:[Ct]},$$scope:{ctx:a}}}),T=new at({props:{name:[{name:"App",comp:C,raw:it,text:""},{name:"Input",comp:C,raw:gt,text:""},{name:"Output",comp:C,raw:wt,text:""},{name:"data.js",comp:C,raw:bt,text:""}]}}),M=new E({props:{$$slots:{default:[Wt]},$$scope:{ctx:a}}}),{c(){w(e.$$.fragment),t=j(),w(r.$$.fragment),o=j(),n=D("pre"),s=j(),w(u.$$.fragment),S=j(),w(x.$$.fragment),O=j(),w(l.$$.fragment),g=j(),w(T.$$.fragment),R=j(),w(M.$$.fragment),this.h()},l($){b(e.$$.fragment,$),t=A($),b(r.$$.fragment,$),o=A($),n=L($,"PRE",{class:!0});var i=y(n);i.forEach(p),s=A($),b(u.$$.fragment,$),S=A($),b(x.$$.fragment,$),O=A($),b(l.$$.fragment,$),g=A($),b(T.$$.fragment,$),R=A($),b(M.$$.fragment,$),this.h()},h(){Y(n,"class","language-js")},m($,i){v(e,$,i),m($,t,i),v(r,$,i),m($,o,i),m($,n,i),n.innerHTML=f,m($,s,i),v(u,$,i),m($,S,i),v(x,$,i),m($,O,i),v(l,$,i),m($,g,i),v(T,$,i),m($,R,i),v(M,$,i),P=!0},p($,i){const N={};i&2&&(N.$$scope={dirty:i,ctx:$}),e.$set(N);const U={};i&2&&(U.$$scope={dirty:i,ctx:$}),r.$set(U);const X={};i&2&&(X.$$scope={dirty:i,ctx:$}),u.$set(X);const Z={};i&2&&(Z.$$scope={dirty:i,ctx:$}),x.$set(Z);const F={};i&2&&(F.$$scope={dirty:i,ctx:$}),l.$set(F);const G={};i&2&&(G.$$scope={dirty:i,ctx:$}),M.$set(G)},i($){P||(d(e.$$.fragment,$),d(r.$$.fragment,$),d(u.$$.fragment,$),d(x.$$.fragment,$),d(l.$$.fragment,$),d(T.$$.fragment,$),d(M.$$.fragment,$),P=!0)},o($){h(e.$$.fragment,$),h(r.$$.fragment,$),h(u.$$.fragment,$),h(x.$$.fragment,$),h(l.$$.fragment,$),h(T.$$.fragment,$),h(M.$$.fragment,$),P=!1},d($){$&&(p(t),p(o),p(n),p(s),p(S),p(O),p(g),p(R)),k(e,$),k(r,$),k(u,$),k(x,$),k(l,$),k(T,$),k(M,$)}}}function zt(a){let e,t;const r=[a[0],V];let o={$$slots:{default:[qt]},$$scope:{ctx:a}};for(let n=0;n<r.length;n+=1)o=z(o,r[n]);return e=new ot({props:o}),{c(){w(e.$$.fragment)},l(n){b(e.$$.fragment,n)},m(n,f){v(e,n,f),t=!0},p(n,[f]){const s=f&1?rt(r,[f&1&&Q(n[0]),f&0&&Q(V)]):{};f&2&&(s.$$scope={dirty:f,ctx:n}),e.$set(s)},i(n){t||(d(e.$$.fragment,n),t=!0)},o(n){h(e.$$.fragment,n),t=!1},d(n){k(e,n)}}}const V={title:"writable store",author:"henrikvilhelmberglund",authorlink:"github.com/henrikvilhelmberglund/",date:"2023-02-12T00:00:00.000Z",layout:"notes"};function Dt(a,e,t){return a.$$set=r=>{t(0,e=z(z({},e),K(r)))},e=K(e),[e]}class Jt extends W{constructor(e){super(),q(this,e,Dt,zt,H,{})}}export{Jt as default,V as metadata};
