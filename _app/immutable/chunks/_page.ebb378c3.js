import{s as E,f as B,l as h,a as O,g as N,h as P,m as w,c as z,u as y,d as m,i as _,v as x,X as S,n as X,z as j,H as Z,aj as ct,ak as $t,A as ut,al as L,C as K,D as ot}from"./scheduler.a7cd560e.js";import{S as V,i as q,b as C,d as k,m as T,a as G,t as A,e as I}from"./index.396264e7.js";import{g as it,a as st}from"./HR.svelte_svelte_type_style_lang.8355a705.js";import{M as ft,P as M}from"./mdsvex-layout-notes.4b2b7ac6.js";import{w as mt}from"./index.5e192797.js";import{S as lt}from"./ShowMany.db7be1f3.js";import{S as D}from"./Strong.097578ae.js";function pt(a){let t,e,n,s,r,c="+",u,i,o="-",$,g;return{c(){t=B("div"),e=h("Grandchildren: "),n=h(a[0]),s=O(),r=B("button"),r.textContent=c,u=O(),i=B("button"),i.textContent=o},l(d){t=N(d,"DIV",{});var f=P(t);e=w(f,"Grandchildren: "),n=w(f,a[0]),s=z(f),r=N(f,"BUTTON",{["data-svelte-h"]:!0}),y(r)!=="svelte-1upznsy"&&(r.textContent=c),u=z(f),i=N(f,"BUTTON",{["data-svelte-h"]:!0}),y(i)!=="svelte-1i0ct90"&&(i.textContent=o),f.forEach(m)},m(d,f){_(d,t,f),x(t,e),x(t,n),x(t,s),x(t,r),x(t,u),x(t,i),$||(g=[S(r,"click",a[1]),S(i,"click",a[2])],$=!0)},p(d,[f]){f&1&&X(n,d[0])},i:j,o:j,d(d){d&&m(t),$=!1,Z(g)}}}function _t(a,t,e){let n=ct("value");return[n,()=>e(0,n++,n),()=>e(0,n--,n)]}class dt extends V{constructor(t){super(),q(this,t,_t,pt,E,{})}}function gt(a){let t,e;return t=new dt({}),{c(){C(t.$$.fragment)},l(n){k(t.$$.fragment,n)},m(n,s){T(t,n,s),e=!0},p:j,i(n){e||(G(t.$$.fragment,n),e=!0)},o(n){A(t.$$.fragment,n),e=!1},d(n){I(t,n)}}}class ht extends V{constructor(t){super(),q(this,t,null,gt,E,{})}}function wt(a){let t,e,n,s,r,c="+",u,i,o="-",$,g,d,f,U;return g=new ht({}),{c(){t=B("div"),e=h("App: "),n=h(a[0]),s=O(),r=B("button"),r.textContent=c,u=O(),i=B("button"),i.textContent=o,$=O(),C(g.$$.fragment)},l(p){t=N(p,"DIV",{});var v=P(t);e=w(v,"App: "),n=w(v,a[0]),s=z(v),r=N(v,"BUTTON",{["data-svelte-h"]:!0}),y(r)!=="svelte-1upznsy"&&(r.textContent=c),u=z(v),i=N(v,"BUTTON",{["data-svelte-h"]:!0}),y(i)!=="svelte-1i0ct90"&&(i.textContent=o),v.forEach(m),$=z(p),k(g.$$.fragment,p)},m(p,v){_(p,t,v),x(t,e),x(t,n),x(t,s),x(t,r),x(t,u),x(t,i),_(p,$,v),T(g,p,v),d=!0,f||(U=[S(r,"click",a[1]),S(i,"click",a[2])],f=!0)},p(p,[v]){(!d||v&1)&&X(n,p[0])},i(p){d||(G(g.$$.fragment,p),d=!0)},o(p){A(g.$$.fragment,p),d=!1},d(p){p&&(m(t),m($)),I(g,p),f=!1,Z(U)}}}function vt(a,t,e){let n=10;return $t("value",n),[n,()=>e(0,n++,n),()=>e(0,n--,n)]}class F extends V{constructor(t){super(),q(this,t,vt,wt,E,{})}}const bt=`<script>\r
	import Child from "./Child.svelte";\r
	import { setContext } from "svelte";\r
\r
	let count = 10;\r
\r
	setContext("value", count);\r
<\/script>\r
\r
<div>\r
	App: {count}\r
	<button on:click={() => count++}>+</button>\r
	<button on:click={() => count--}>-</button>\r
</div>\r
\r
<Child />\r
`,xt=`<script>\r
	import Grandchildren from "./Grandchildren.svelte";\r
<\/script>\r
\r
<Grandchildren />\r
`,Ct=`<script>\r
	import { getContext } from "svelte";\r
\r
	let count = getContext("value");\r
<\/script>\r
\r
<div>\r
	Grandchildren: {count}\r
	<button on:click={() => count++}>+</button>\r
	<button on:click={() => count--}>-</button>\r
</div>\r
`;function kt(a){let t,e,n,s,r,c="+",u,i,o="-",$,g;return{c(){t=B("div"),e=h("Grandchildren: "),n=h(a[0]),s=O(),r=B("button"),r.textContent=c,u=O(),i=B("button"),i.textContent=o},l(d){t=N(d,"DIV",{});var f=P(t);e=w(f,"Grandchildren: "),n=w(f,a[0]),s=z(f),r=N(f,"BUTTON",{["data-svelte-h"]:!0}),y(r)!=="svelte-cqecfo"&&(r.textContent=c),u=z(f),i=N(f,"BUTTON",{["data-svelte-h"]:!0}),y(i)!=="svelte-vzsx9e"&&(i.textContent=o),f.forEach(m)},m(d,f){_(d,t,f),x(t,e),x(t,n),x(t,s),x(t,r),x(t,u),x(t,i),$||(g=[S(r,"click",a[2]),S(i,"click",a[3])],$=!0)},p(d,[f]){f&1&&X(n,d[0])},i:j,o:j,d(d){d&&m(t),$=!1,Z(g)}}}function Tt(a,t,e){let n,s=ct("value");return ut(a,s,u=>e(0,n=u)),[n,s,()=>L(s,n++,n),()=>L(s,n--,n)]}class Gt extends V{constructor(t){super(),q(this,t,Tt,kt,E,{})}}function At(a){let t,e;return t=new Gt({}),{c(){C(t.$$.fragment)},l(n){k(t.$$.fragment,n)},m(n,s){T(t,n,s),e=!0},p:j,i(n){e||(G(t.$$.fragment,n),e=!0)},o(n){A(t.$$.fragment,n),e=!1},d(n){I(t,n)}}}class It extends V{constructor(t){super(),q(this,t,null,At,E,{})}}function Ot(a){let t,e,n,s,r,c="+",u,i,o="-",$,g,d,f,U;return g=new It({}),{c(){t=B("div"),e=h("App: "),n=h(a[0]),s=O(),r=B("button"),r.textContent=c,u=O(),i=B("button"),i.textContent=o,$=O(),C(g.$$.fragment)},l(p){t=N(p,"DIV",{});var v=P(t);e=w(v,"App: "),n=w(v,a[0]),s=z(v),r=N(v,"BUTTON",{["data-svelte-h"]:!0}),y(r)!=="svelte-cqecfo"&&(r.textContent=c),u=z(v),i=N(v,"BUTTON",{["data-svelte-h"]:!0}),y(i)!=="svelte-vzsx9e"&&(i.textContent=o),v.forEach(m),$=z(p),k(g.$$.fragment,p)},m(p,v){_(p,t,v),x(t,e),x(t,n),x(t,s),x(t,r),x(t,u),x(t,i),_(p,$,v),T(g,p,v),d=!0,f||(U=[S(r,"click",a[2]),S(i,"click",a[3])],f=!0)},p(p,[v]){(!d||v&1)&&X(n,p[0])},i(p){d||(G(g.$$.fragment,p),d=!0)},o(p){A(g.$$.fragment,p),d=!1},d(p){p&&(m(t),m($)),I(g,p),f=!1,Z(U)}}}function zt(a,t,e){let n,s=mt(10);return ut(a,s,u=>e(0,n=u)),$t("value",s),[n,s,()=>L(s,n++,n),()=>L(s,n--,n)]}class J extends V{constructor(t){super(),q(this,t,zt,Ot,E,{})}}const Bt=`<script>\r
	import Child2 from "./Child2.svelte";\r
  import { writable } from "svelte/store";\r
	import { setContext } from "svelte";\r
\r
	let count = writable(10);\r
\r
	setContext("value", count);\r
<\/script>\r
\r
<div>\r
	App: {$count}\r
	<button on:click={() => $count++}>+</button>\r
	<button on:click={() => $count--}>-</button>\r
</div>\r
\r
<Child2 />\r
`,Nt=`<script>\r
	import Grandchildren2 from "./Grandchildren2.svelte";\r
<\/script>\r
\r
<Grandchildren2 />\r
`,Ut=`<script>\r
	import { getContext } from "svelte";\r
\r
	let count = getContext("value");\r
<\/script>\r
\r
<div>\r
	Grandchildren: {$count}\r
	<button on:click={() => $count++}>+</button>\r
	<button on:click={() => $count--}>-</button>\r
</div>\r
`;function Dt(a){let t;return{c(){t=h("external store")},l(e){t=w(e,"external store")},m(e,n){_(e,t,n)},d(e){e&&m(t)}}}function Rt(a){let t,e,n,s;return e=new D({props:{$$slots:{default:[Dt]},$$scope:{ctx:a}}}),{c(){t=h("If we want our data to not be linked to our components in any way we could use an "),C(e.$$.fragment),n=h(", but here we want to share the data between only the main component, the children and the grandchildren.")},l(r){t=w(r,"If we want our data to not be linked to our components in any way we could use an "),k(e.$$.fragment,r),n=w(r,", but here we want to share the data between only the main component, the children and the grandchildren.")},m(r,c){_(r,t,c),T(e,r,c),_(r,n,c),s=!0},p(r,c){const u={};c&2&&(u.$$scope={dirty:c,ctx:r}),e.$set(u)},i(r){s||(G(e.$$.fragment,r),s=!0)},o(r){A(e.$$.fragment,r),s=!1},d(r){r&&(m(t),m(n)),I(e,r)}}}function yt(a){let t;return{c(){t=h("context")},l(e){t=w(e,"context")},m(e,n){_(e,t,n)},d(e){e&&m(t)}}}function St(a){let t,e,n,s;return e=new D({props:{$$slots:{default:[yt]},$$scope:{ctx:a}}}),{c(){t=h("That's why we will use "),C(e.$$.fragment),n=h(" here.")},l(r){t=w(r,"That's why we will use "),k(e.$$.fragment,r),n=w(r," here.")},m(r,c){_(r,t,c),T(e,r,c),_(r,n,c),s=!0},p(r,c){const u={};c&2&&(u.$$scope={dirty:c,ctx:r}),e.$set(u)},i(r){s||(G(e.$$.fragment,r),s=!0)},o(r){A(e.$$.fragment,r),s=!1},d(r){r&&(m(t),m(n)),I(e,r)}}}function Mt(a){let t;return{c(){t=h("key")},l(e){t=w(e,"key")},m(e,n){_(e,t,n)},d(e){e&&m(t)}}}function Et(a){let t;return{c(){t=h("value")},l(e){t=w(e,"value")},m(e,n){_(e,t,n)},d(e){e&&m(t)}}}function Vt(a){let t;return{c(){t=h("component initialization")},l(e){t=w(e,"component initialization")},m(e,n){_(e,t,n)},d(e){e&&m(t)}}}function qt(a){let t,e,n,s,r,c,u,i;return e=new D({props:{$$slots:{default:[Mt]},$$scope:{ctx:a}}}),s=new D({props:{$$slots:{default:[Et]},$$scope:{ctx:a}}}),c=new D({props:{$$slots:{default:[Vt]},$$scope:{ctx:a}}}),{c(){t=h("setContext() takes a "),C(e.$$.fragment),n=h(" and a "),C(s.$$.fragment),r=h(" as parameters. The context is set and get upon "),C(c.$$.fragment),u=h(" (whenever it is mounted in the DOM).")},l(o){t=w(o,"setContext() takes a "),k(e.$$.fragment,o),n=w(o," and a "),k(s.$$.fragment,o),r=w(o," as parameters. The context is set and get upon "),k(c.$$.fragment,o),u=w(o," (whenever it is mounted in the DOM).")},m(o,$){_(o,t,$),T(e,o,$),_(o,n,$),T(s,o,$),_(o,r,$),T(c,o,$),_(o,u,$),i=!0},p(o,$){const g={};$&2&&(g.$$scope={dirty:$,ctx:o}),e.$set(g);const d={};$&2&&(d.$$scope={dirty:$,ctx:o}),s.$set(d);const f={};$&2&&(f.$$scope={dirty:$,ctx:o}),c.$set(f)},i(o){i||(G(e.$$.fragment,o),G(s.$$.fragment,o),G(c.$$.fragment,o),i=!0)},o(o){A(e.$$.fragment,o),A(s.$$.fragment,o),A(c.$$.fragment,o),i=!1},d(o){o&&(m(t),m(n),m(r),m(u)),I(e,o),I(s,o),I(c,o)}}}function jt(a){let t;return{c(){t=h("set an initial value")},l(e){t=w(e,"set an initial value")},m(e,n){_(e,t,n)},d(e){e&&m(t)}}}function Ht(a){let t;return{c(){t=h("the other won't change")},l(e){t=w(e,"the other won't change")},m(e,n){_(e,t,n)},d(e){e&&m(t)}}}function Lt(a){let t;return{c(){t=h("not by reference")},l(e){t=w(e,"not by reference")},m(e,n){_(e,t,n)},d(e){e&&m(t)}}}function Pt(a){let t,e,n,s,r,c,u,i;return e=new D({props:{$$slots:{default:[jt]},$$scope:{ctx:a}}}),s=new D({props:{$$slots:{default:[Ht]},$$scope:{ctx:a}}}),c=new D({props:{$$slots:{default:[Lt]},$$scope:{ctx:a}}}),{c(){t=h("This means that we can "),C(e.$$.fragment),n=h(" but after that if we increase count in one of the components "),C(s.$$.fragment),r=h(" because we're getting the value by value, "),C(c.$$.fragment),u=h(".")},l(o){t=w(o,"This means that we can "),k(e.$$.fragment,o),n=w(o," but after that if we increase count in one of the components "),k(s.$$.fragment,o),r=w(o," because we're getting the value by value, "),k(c.$$.fragment,o),u=w(o,".")},m(o,$){_(o,t,$),T(e,o,$),_(o,n,$),T(s,o,$),_(o,r,$),T(c,o,$),_(o,u,$),i=!0},p(o,$){const g={};$&2&&(g.$$scope={dirty:$,ctx:o}),e.$set(g);const d={};$&2&&(d.$$scope={dirty:$,ctx:o}),s.$set(d);const f={};$&2&&(f.$$scope={dirty:$,ctx:o}),c.$set(f)},i(o){i||(G(e.$$.fragment,o),G(s.$$.fragment,o),G(c.$$.fragment,o),i=!0)},o(o){A(e.$$.fragment,o),A(s.$$.fragment,o),A(c.$$.fragment,o),i=!1},d(o){o&&(m(t),m(n),m(r),m(u)),I(e,o),I(s,o),I(c,o)}}}function Xt(a){let t;return{c(){t=h("This is the reason we're going to use a store in combination with context.")},l(e){t=w(e,"This is the reason we're going to use a store in combination with context.")},m(e,n){_(e,t,n)},d(e){e&&m(t)}}}function Zt(a){let t;return{c(){t=h("Let's try to sync the value using a store.")},l(e){t=w(e,"Let's try to sync the value using a store.")},m(e,n){_(e,t,n)},d(e){e&&m(t)}}}function Ft(a){let t;return{c(){t=h("store in combination with context")},l(e){t=w(e,"store in combination with context")},m(e,n){_(e,t,n)},d(e){e&&m(t)}}}function Jt(a){let t,e,n,s;return e=new D({props:{$$slots:{default:[Ft]},$$scope:{ctx:a}}}),{c(){t=h("It works! If we want to sync values down the chain of components we can use "),C(e.$$.fragment),n=h(".")},l(r){t=w(r,"It works! If we want to sync values down the chain of components we can use "),k(e.$$.fragment,r),n=w(r,".")},m(r,c){_(r,t,c),T(e,r,c),_(r,n,c),s=!0},p(r,c){const u={};c&2&&(u.$$scope={dirty:c,ctx:r}),e.$set(u)},i(r){s||(G(e.$$.fragment,r),s=!0)},o(r){A(e.$$.fragment,r),s=!1},d(r){r&&(m(t),m(n)),I(e,r)}}}function Kt(a){let t,e,n,s,r,c,u,i,o,$,g,d,f,U,p,v,R,H;return t=new M({props:{$$slots:{default:[Rt]},$$scope:{ctx:a}}}),n=new M({props:{$$slots:{default:[St]},$$scope:{ctx:a}}}),r=new M({props:{$$slots:{default:[qt]},$$scope:{ctx:a}}}),u=new M({props:{$$slots:{default:[Pt]},$$scope:{ctx:a}}}),o=new M({props:{$$slots:{default:[Xt]},$$scope:{ctx:a}}}),g=new lt({props:{name:[{name:"App",comp:F,raw:bt,text:"This is an example where the value is synced once at component initialization but then loses sync."},{name:"Child",comp:F,raw:xt,text:""},{name:"Grandchildren",comp:F,raw:Ct,text:""}]}}),f=new M({props:{$$slots:{default:[Zt]},$$scope:{ctx:a}}}),p=new lt({props:{name:[{name:"App2",comp:J,raw:Bt,text:"Here we're using a writable store."},{name:"Child2",comp:J,raw:Nt,text:""},{name:"Grandchildren2",comp:J,raw:Ut,text:""}]}}),R=new M({props:{$$slots:{default:[Jt]},$$scope:{ctx:a}}}),{c(){C(t.$$.fragment),e=O(),C(n.$$.fragment),s=O(),C(r.$$.fragment),c=O(),C(u.$$.fragment),i=O(),C(o.$$.fragment),$=O(),C(g.$$.fragment),d=O(),C(f.$$.fragment),U=O(),C(p.$$.fragment),v=O(),C(R.$$.fragment)},l(l){k(t.$$.fragment,l),e=z(l),k(n.$$.fragment,l),s=z(l),k(r.$$.fragment,l),c=z(l),k(u.$$.fragment,l),i=z(l),k(o.$$.fragment,l),$=z(l),k(g.$$.fragment,l),d=z(l),k(f.$$.fragment,l),U=z(l),k(p.$$.fragment,l),v=z(l),k(R.$$.fragment,l)},m(l,b){T(t,l,b),_(l,e,b),T(n,l,b),_(l,s,b),T(r,l,b),_(l,c,b),T(u,l,b),_(l,i,b),T(o,l,b),_(l,$,b),T(g,l,b),_(l,d,b),T(f,l,b),_(l,U,b),T(p,l,b),_(l,v,b),T(R,l,b),H=!0},p(l,b){const Q={};b&2&&(Q.$$scope={dirty:b,ctx:l}),t.$set(Q);const W={};b&2&&(W.$$scope={dirty:b,ctx:l}),n.$set(W);const Y={};b&2&&(Y.$$scope={dirty:b,ctx:l}),r.$set(Y);const tt={};b&2&&(tt.$$scope={dirty:b,ctx:l}),u.$set(tt);const et={};b&2&&(et.$$scope={dirty:b,ctx:l}),o.$set(et);const nt={};b&2&&(nt.$$scope={dirty:b,ctx:l}),f.$set(nt);const rt={};b&2&&(rt.$$scope={dirty:b,ctx:l}),R.$set(rt)},i(l){H||(G(t.$$.fragment,l),G(n.$$.fragment,l),G(r.$$.fragment,l),G(u.$$.fragment,l),G(o.$$.fragment,l),G(g.$$.fragment,l),G(f.$$.fragment,l),G(p.$$.fragment,l),G(R.$$.fragment,l),H=!0)},o(l){A(t.$$.fragment,l),A(n.$$.fragment,l),A(r.$$.fragment,l),A(u.$$.fragment,l),A(o.$$.fragment,l),A(g.$$.fragment,l),A(f.$$.fragment,l),A(p.$$.fragment,l),A(R.$$.fragment,l),H=!1},d(l){l&&(m(e),m(s),m(c),m(i),m($),m(d),m(U),m(v)),I(t,l),I(n,l),I(r,l),I(u,l),I(o,l),I(g,l),I(f,l),I(p,l),I(R,l)}}}function Qt(a){let t,e;const n=[a[0],at];let s={$$slots:{default:[Kt]},$$scope:{ctx:a}};for(let r=0;r<n.length;r+=1)s=K(s,n[r]);return t=new ft({props:s}),{c(){C(t.$$.fragment)},l(r){k(t.$$.fragment,r)},m(r,c){T(t,r,c),e=!0},p(r,[c]){const u=c&1?it(n,[c&1&&st(r[0]),c&0&&st(at)]):{};c&2&&(u.$$scope={dirty:c,ctx:r}),t.$set(u)},i(r){e||(G(t.$$.fragment,r),e=!0)},o(r){A(t.$$.fragment,r),e=!1},d(r){I(t,r)}}}const at={title:"Reactive context",author:"henrikvilhelmberglund",authorlink:"github.com/henrikvilhelmberglund/",date:"2023-03-31T00:00:00.000Z",layout:"notes"};function Wt(a,t,e){return a.$$set=n=>{e(0,t=K(K({},t),ot(n)))},t=ot(t),[t]}class le extends V{constructor(t){super(),q(this,t,Wt,Qt,E,{})}}export{le as default,at as metadata};
