import{s as W,f as S,a as T,g as U,c as x,u as rt,j as dt,i,X as G,z as O,d as l,o as vt,p as $t,N as Tt,l as h,h as bt,m as v,v as Ct,n as ht,C as ft,D as _t}from"./scheduler.a7cd560e.js";import{S as X,i as Z,b as _,d as g,m as w,a as d,t as b,e as C}from"./index.396264e7.js";import{g as xt,a as gt}from"./HR.svelte_svelte_type_style_lang.8355a705.js";import{M as kt,P as L}from"./mdsvex-layout-notes.4b2b7ac6.js";import{S as F}from"./ShowCode.9be9983a.js";import{S as M}from"./Strong.097578ae.js";import{C as Mt}from"./Code.64283003.js";function At(m){let t,e,n,$="Reset",r,f;return{c(){t=S("input"),e=T(),n=S("button"),n.textContent=$,this.h()},l(s){t=U(s,"INPUT",{type:!0}),e=x(s),n=U(s,"BUTTON",{["data-svelte-h"]:!0}),rt(n)!=="svelte-jn3jzs"&&(n.textContent=$),this.h()},h(){dt(t,"type","text")},m(s,p){i(s,t,p),m[2](t),i(s,e,p),i(s,n,p),r||(f=G(n,"click",m[1]),r=!0)},p:O,i:O,o:O,d(s){s&&(l(t),l(e),l(n)),m[2](null),r=!1,f()}}}function Ot(m,t,e){let n;function $(){e(0,n.value="",n)}vt(()=>{console.log(n)});function r(f){$t[f?"unshift":"push"](()=>{n=f,e(0,n)})}return[n,$,r]}class Rt extends X{constructor(t){super(),Z(this,t,Ot,At,W,{})}}const It=`<script>\r
	import { onMount } from "svelte";\r
	let element;\r
	function reset() {\r
		element.value = "";\r
	}\r
	onMount(() => {\r
		console.log(element);\r
	});\r
<\/script>\r
\r
<input bind:this={element} type="text" />\r
\r
<button on:click={reset}>Reset</button>\r
`;function Nt(m){let t,e,n,$="Reset",r,f;return{c(){t=S("input"),e=T(),n=S("button"),n.textContent=$,this.h()},l(s){t=U(s,"INPUT",{type:!0}),e=x(s),n=U(s,"BUTTON",{["data-svelte-h"]:!0}),rt(n)!=="svelte-jn3jzs"&&(n.textContent=$),this.h()},h(){dt(t,"type","text")},m(s,p){i(s,t,p),m[2](t),i(s,e,p),i(s,n,p),r||(f=G(n,"click",m[1]),r=!0)},p:O,i:O,o:O,d(s){s&&(l(t),l(e),l(n)),m[2](null),r=!1,f()}}}function St(m,t,e){let n;function $(){e(0,n.value="",n)}function r(f){$t[f?"unshift":"push"](()=>{n=f,e(0,n)})}return[n,$,r]}class Ut extends X{constructor(t){super(),Z(this,t,St,Nt,W,{})}}const Dt=`<script>\r
	let element;\r
	function reset() {\r
		element.value = "";\r
	}\r
<\/script>\r
\r
<input bind:this={element} type="text" />\r
\r
<button on:click={reset}>Reset</button>`;function jt(m){let t,e,n,$;return{c(){t=S("button"),e=h(m[0])},l(r){t=U(r,"BUTTON",{});var f=bt(t);e=v(f,m[0]),f.forEach(l)},m(r,f){i(r,t,f),Ct(t,e),n||($=G(t,"click",m[1]),n=!0)},p(r,[f]){f&1&&ht(e,r[0])},i:O,o:O,d(r){r&&l(t),n=!1,$()}}}function Bt(m,t,e){let{count:n=0}=t;function $(){e(0,n=0)}function r(){e(0,n++,n)}return m.$$set=f=>{"count"in f&&e(0,n=f.count)},[n,r,$]}class yt extends X{constructor(t){super(),Z(this,t,Bt,jt,W,{count:0,reset:2})}get count(){return this.$$.ctx[0]}set count(t){this.$$set({count:t}),Tt()}get reset(){return this.$$.ctx[2]}}function Pt(m){let t,e,n,$="Log Component.svelte's Count",r,f,s,p={};return t=new yt({props:p}),m[2](t),{c(){_(t.$$.fragment),e=T(),n=S("button"),n.textContent=$},l(u){g(t.$$.fragment,u),e=x(u),n=U(u,"BUTTON",{["data-svelte-h"]:!0}),rt(n)!=="svelte-19off5q"&&(n.textContent=$)},m(u,a){w(t,u,a),i(u,e,a),i(u,n,a),r=!0,f||(s=G(n,"click",m[1]),f=!0)},p(u,[a]){const k={};t.$set(k)},i(u){r||(d(t.$$.fragment,u),r=!0)},o(u){b(t.$$.fragment,u),r=!1},d(u){u&&(l(e),l(n)),m[2](null),C(t,u),f=!1,s()}}}function zt(m,t,e){let n;function $(){console.log(n.count)}function r(f){$t[f?"unshift":"push"](()=>{n=f,e(0,n)})}return[n,$,r]}class qt extends X{constructor(t){super(),Z(this,t,zt,Pt,W,{})}}const Et=`<script>\r
	let myComponent;\r
	function logCount() {\r
		console.log(myComponent.count);\r
	}\r
	import Component from "./Component.svelte";\r
<\/script>\r
\r
<Component bind:this={myComponent} />\r
\r
<button on:click={logCount}>Log Component.svelte's Count</button>\r
`;function Lt(m){let t,e,n,$;return{c(){t=S("button"),e=h(m[0])},l(r){t=U(r,"BUTTON",{});var f=bt(t);e=v(f,m[0]),f.forEach(l)},m(r,f){i(r,t,f),Ct(t,e),n||($=G(t,"click",m[1]),n=!0)},p(r,[f]){f&1&&ht(e,r[0])},i:O,o:O,d(r){r&&l(t),n=!1,$()}}}function Wt(m,t,e){let n=0;function $(){e(0,n=0)}function r(){e(0,n++,n)}return[n,r,$]}class Xt extends X{constructor(t){super(),Z(this,t,Wt,Lt,W,{reset:2})}get reset(){return this.$$.ctx[2]}}function Zt(m){let t,e,n,$="Reset Component2.svelte's Count",r,f,s,p={};return t=new Xt({props:p}),m[2](t),{c(){_(t.$$.fragment),e=T(),n=S("button"),n.textContent=$},l(u){g(t.$$.fragment,u),e=x(u),n=U(u,"BUTTON",{["data-svelte-h"]:!0}),rt(n)!=="svelte-h6x0p"&&(n.textContent=$)},m(u,a){w(t,u,a),i(u,e,a),i(u,n,a),r=!0,f||(s=G(n,"click",m[1]),f=!0)},p(u,[a]){const k={};t.$set(k)},i(u){r||(d(t.$$.fragment,u),r=!0)},o(u){b(t.$$.fragment,u),r=!1},d(u){u&&(l(e),l(n)),m[2](null),C(t,u),f=!1,s()}}}function Ft(m,t,e){let n;function $(){n.reset()}function r(f){$t[f?"unshift":"push"](()=>{n=f,e(0,n)})}return[n,$,r]}class Gt extends X{constructor(t){super(),Z(this,t,Ft,Zt,W,{})}}const Ht=`<script>\r
	let myComponent;\r
	function reset() {\r
		myComponent.reset();\r
	}\r
	import Component2 from "./Component2.svelte";\r
<\/script>\r
\r
<Component2 bind:this={myComponent} />\r
\r
<button on:click={reset}>Reset Component2.svelte's Count</button>\r
`,Jt=`<!-- we also need this to create getters and setters for the component's props -->\r
<svelte:options accessors />\r
\r
<script>\r
	export let count = 0;\r
\r
	// exporting a function as a prop\r
	export function reset() {\r
		count = 0;\r
	}\r
	function inc() {\r
		count++;\r
	}\r
<\/script>\r
\r
<button on:click={inc}>{count}</button>\r
`,Kt=`<script>\r
	let count = 0;\r
\r
	// exporting a function as a prop (or, with bind:this, as a method)\r
	export function reset() {\r
		count = 0;\r
	}\r
	function inc() {\r
		count++;\r
	}\r
<\/script>\r
\r
<button on:click={inc}>{count}</button>\r
`;function Qt(m){let t;return{c(){t=h("bind:this")},l(e){t=v(e,"bind:this")},m(e,n){i(e,t,n)},d(e){e&&l(t)}}}function Vt(m){let t;return{c(){t=h("one-way binding")},l(e){t=v(e,"one-way binding")},m(e,n){i(e,t,n)},d(e){e&&l(t)}}}function Yt(m){let t,e,n,$,r,f;return e=new M({props:{$$slots:{default:[Qt]},$$scope:{ctx:m}}}),$=new M({props:{$$slots:{default:[Vt]},$$scope:{ctx:m}}}),{c(){t=h("If we want to get a reference to a DOM element we can use "),_(e.$$.fragment),n=h(". bind:this is a "),_($.$$.fragment),r=h(".")},l(s){t=v(s,"If we want to get a reference to a DOM element we can use "),g(e.$$.fragment,s),n=v(s,". bind:this is a "),g($.$$.fragment,s),r=v(s,".")},m(s,p){i(s,t,p),w(e,s,p),i(s,n,p),w($,s,p),i(s,r,p),f=!0},p(s,p){const u={};p&2&&(u.$$scope={dirty:p,ctx:s}),e.$set(u);const a={};p&2&&(a.$$scope={dirty:p,ctx:s}),$.$set(a)},i(s){f||(d(e.$$.fragment,s),d($.$$.fragment,s),f=!0)},o(s){b(e.$$.fragment,s),b($.$$.fragment,s),f=!1},d(s){s&&(l(t),l(n),l(r)),C(e,s),C($,s)}}}function te(m){let t;return{c(){t=h("undefined")},l(e){t=v(e,"undefined")},m(e,n){i(e,t,n)},d(e){e&&l(t)}}}function ee(m){let t;return{c(){t=h("when Svelte creates the element and mounts it onto the DOM")},l(e){t=v(e,"when Svelte creates the element and mounts it onto the DOM")},m(e,n){i(e,t,n)},d(e){e&&l(t)}}}function ne(m){let t,e,n,$,r,f;return e=new M({props:{$$slots:{default:[te]},$$scope:{ctx:m}}}),$=new M({props:{$$slots:{default:[ee]},$$scope:{ctx:m}}}),{c(){t=h("If we have a variable and assign an element to it using bind:this and try to console.log() immediately it we will get "),_(e.$$.fragment),n=h(" because it is getting defined "),_($.$$.fragment),r=h(".")},l(s){t=v(s,"If we have a variable and assign an element to it using bind:this and try to console.log() immediately it we will get "),g(e.$$.fragment,s),n=v(s," because it is getting defined "),g($.$$.fragment,s),r=v(s,".")},m(s,p){i(s,t,p),w(e,s,p),i(s,n,p),w($,s,p),i(s,r,p),f=!0},p(s,p){const u={};p&2&&(u.$$scope={dirty:p,ctx:s}),e.$set(u);const a={};p&2&&(a.$$scope={dirty:p,ctx:s}),$.$set(a)},i(s){f||(d(e.$$.fragment,s),d($.$$.fragment,s),f=!0)},o(s){b(e.$$.fragment,s),b($.$$.fragment,s),f=!1},d(s){s&&(l(t),l(n),l(r)),C(e,s),C($,s)}}}function se(m){let t;return{c(){t=h("onMount lifecycle event")},l(e){t=v(e,"onMount lifecycle event")},m(e,n){i(e,t,n)},d(e){e&&l(t)}}}function oe(m){let t;return{c(){t=h("the component is mounted onto the DOM")},l(e){t=v(e,"the component is mounted onto the DOM")},m(e,n){i(e,t,n)},d(e){e&&l(t)}}}function re(m){let t,e,n,$,r,f;return e=new M({props:{$$slots:{default:[se]},$$scope:{ctx:m}}}),$=new M({props:{$$slots:{default:[oe]},$$scope:{ctx:m}}}),{c(){t=h("To get around this we can use the "),_(e.$$.fragment),n=h(" that is run when "),_($.$$.fragment),r=h(".")},l(s){t=v(s,"To get around this we can use the "),g(e.$$.fragment,s),n=v(s," that is run when "),g($.$$.fragment,s),r=v(s,".")},m(s,p){i(s,t,p),w(e,s,p),i(s,n,p),w($,s,p),i(s,r,p),f=!0},p(s,p){const u={};p&2&&(u.$$scope={dirty:p,ctx:s}),e.$set(u);const a={};p&2&&(a.$$scope={dirty:p,ctx:s}),$.$set(a)},i(s){f||(d(e.$$.fragment,s),d($.$$.fragment,s),f=!0)},o(s){b(e.$$.fragment,s),b($.$$.fragment,s),f=!1},d(s){s&&(l(t),l(n),l(r)),C(e,s),C($,s)}}}function $e(m){let t;return{c(){t=h("To be clear, if we don't use the element right away the onMount event isn't necessarily needed. In a simple case this would be enough:")},l(e){t=v(e,"To be clear, if we don't use the element right away the onMount event isn't necessarily needed. In a simple case this would be enough:")},m(e,n){i(e,t,n)},d(e){e&&l(t)}}}function fe(m){let t;return{c(){t=h("component")},l(e){t=v(e,"component")},m(e,n){i(e,t,n)},d(e){e&&l(t)}}}function ue(m){let t,e,n,$;return e=new M({props:{$$slots:{default:[fe]},$$scope:{ctx:m}}}),{c(){t=h("If we use bind:this on a "),_(e.$$.fragment),n=h(" we get access to its props as well.")},l(r){t=v(r,"If we use bind:this on a "),g(e.$$.fragment,r),n=v(r," we get access to its props as well.")},m(r,f){i(r,t,f),w(e,r,f),i(r,n,f),$=!0},p(r,f){const s={};f&2&&(s.$$scope={dirty:f,ctx:r}),e.$set(s)},i(r){$||(d(e.$$.fragment,r),$=!0)},o(r){b(e.$$.fragment,r),$=!1},d(r){r&&(l(t),l(n)),C(e,r)}}}function me(m){let t;return{c(){t=h("<svelte:options accessors />")},l(e){t=v(e,"<svelte:options accessors />")},m(e,n){i(e,t,n)},d(e){e&&l(t)}}}function pe(m){let t,e;return t=new Mt({props:{$$slots:{default:[me]},$$scope:{ctx:m}}}),{c(){_(t.$$.fragment)},l(n){g(t.$$.fragment,n)},m(n,$){w(t,n,$),e=!0},p(n,$){const r={};$&2&&(r.$$scope={dirty:$,ctx:n}),t.$set(r)},i(n){e||(d(t.$$.fragment,n),e=!0)},o(n){b(t.$$.fragment,n),e=!1},d(n){C(t,n)}}}function le(m){let t;return{c(){t=h("count")},l(e){t=v(e,"count")},m(e,n){i(e,t,n)},d(e){e&&l(t)}}}function ie(m){let t;return{c(){t=h("functions")},l(e){t=v(e,"functions")},m(e,n){i(e,t,n)},d(e){e&&l(t)}}}function ce(m){let t,e,n,$,r,f,s,p;return e=new M({props:{$$slots:{default:[pe]},$$scope:{ctx:m}}}),$=new M({props:{$$slots:{default:[le]},$$scope:{ctx:m}}}),f=new M({props:{$$slots:{default:[ie]},$$scope:{ctx:m}}}),{c(){t=h("We do need "),_(e.$$.fragment),n=h(" in order to get access to the "),_($.$$.fragment),r=h(" variable since it wasn't readonly, but for "),_(f.$$.fragment),s=h(" we don't need it.")},l(u){t=v(u,"We do need "),g(e.$$.fragment,u),n=v(u," in order to get access to the "),g($.$$.fragment,u),r=v(u," variable since it wasn't readonly, but for "),g(f.$$.fragment,u),s=v(u," we don't need it.")},m(u,a){i(u,t,a),w(e,u,a),i(u,n,a),w($,u,a),i(u,r,a),w(f,u,a),i(u,s,a),p=!0},p(u,a){const k={};a&2&&(k.$$scope={dirty:a,ctx:u}),e.$set(k);const D={};a&2&&(D.$$scope={dirty:a,ctx:u}),$.$set(D);const A={};a&2&&(A.$$scope={dirty:a,ctx:u}),f.$set(A)},i(u){p||(d(e.$$.fragment,u),d($.$$.fragment,u),d(f.$$.fragment,u),p=!0)},o(u){b(e.$$.fragment,u),b($.$$.fragment,u),b(f.$$.fragment,u),p=!1},d(u){u&&(l(t),l(n),l(r),l(s)),C(e,u),C($,u),C(f,u)}}}function ae(m){let t;return{c(){t=h("bind:this")},l(e){t=v(e,"bind:this")},m(e,n){i(e,t,n)},d(e){e&&l(t)}}}function _e(m){let t;return{c(){t=h("methods")},l(e){t=v(e,"methods")},m(e,n){i(e,t,n)},d(e){e&&l(t)}}}function ge(m){let t,e,n,$,r,f;return e=new M({props:{$$slots:{default:[ae]},$$scope:{ctx:m}}}),$=new M({props:{$$slots:{default:[_e]},$$scope:{ctx:m}}}),{c(){t=h("This way we can export functions from a component and use it in another component where we bind to it using "),_(e.$$.fragment),n=h(" so we can use its "),_($.$$.fragment),r=h(".")},l(s){t=v(s,"This way we can export functions from a component and use it in another component where we bind to it using "),g(e.$$.fragment,s),n=v(s," so we can use its "),g($.$$.fragment,s),r=v(s,".")},m(s,p){i(s,t,p),w(e,s,p),i(s,n,p),w($,s,p),i(s,r,p),f=!0},p(s,p){const u={};p&2&&(u.$$scope={dirty:p,ctx:s}),e.$set(u);const a={};p&2&&(a.$$scope={dirty:p,ctx:s}),$.$set(a)},i(s){f||(d(e.$$.fragment,s),d($.$$.fragment,s),f=!0)},o(s){b(e.$$.fragment,s),b($.$$.fragment,s),f=!1},d(s){s&&(l(t),l(n),l(r)),C(e,s),C($,s)}}}function we(m){let t,e,n,$,r,f,s,p,u,a,k,D,A,H,j,J,R,K,B,Q,y,V,P,Y,I,tt,z,et,q,nt,E,st,N,ot;return t=new L({props:{$$slots:{default:[Yt]},$$scope:{ctx:m}}}),n=new L({props:{$$slots:{default:[ne]},$$scope:{ctx:m}}}),r=new L({props:{$$slots:{default:[re]},$$scope:{ctx:m}}}),s=new Rt({}),u=new F({props:{code:It,name:"App.svelte"}}),k=new L({props:{$$slots:{default:[$e]},$$scope:{ctx:m}}}),A=new Ut({}),j=new F({props:{code:Dt,name:"App2.svelte"}}),R=new L({props:{$$slots:{default:[ue]},$$scope:{ctx:m}}}),B=new qt({}),y=new F({props:{code:Et,name:"App3.svelte"}}),P=new F({props:{code:Jt,name:"Component.svelte"}}),I=new L({props:{$$slots:{default:[ce]},$$scope:{ctx:m}}}),z=new Gt({}),q=new F({props:{code:Ht,name:"App4.svelte"}}),E=new F({props:{code:Kt,name:"Component2.svelte"}}),N=new L({props:{$$slots:{default:[ge]},$$scope:{ctx:m}}}),{c(){_(t.$$.fragment),e=T(),_(n.$$.fragment),$=T(),_(r.$$.fragment),f=T(),_(s.$$.fragment),p=T(),_(u.$$.fragment),a=T(),_(k.$$.fragment),D=T(),_(A.$$.fragment),H=T(),_(j.$$.fragment),J=T(),_(R.$$.fragment),K=T(),_(B.$$.fragment),Q=T(),_(y.$$.fragment),V=T(),_(P.$$.fragment),Y=T(),_(I.$$.fragment),tt=T(),_(z.$$.fragment),et=T(),_(q.$$.fragment),nt=T(),_(E.$$.fragment),st=T(),_(N.$$.fragment)},l(o){g(t.$$.fragment,o),e=x(o),g(n.$$.fragment,o),$=x(o),g(r.$$.fragment,o),f=x(o),g(s.$$.fragment,o),p=x(o),g(u.$$.fragment,o),a=x(o),g(k.$$.fragment,o),D=x(o),g(A.$$.fragment,o),H=x(o),g(j.$$.fragment,o),J=x(o),g(R.$$.fragment,o),K=x(o),g(B.$$.fragment,o),Q=x(o),g(y.$$.fragment,o),V=x(o),g(P.$$.fragment,o),Y=x(o),g(I.$$.fragment,o),tt=x(o),g(z.$$.fragment,o),et=x(o),g(q.$$.fragment,o),nt=x(o),g(E.$$.fragment,o),st=x(o),g(N.$$.fragment,o)},m(o,c){w(t,o,c),i(o,e,c),w(n,o,c),i(o,$,c),w(r,o,c),i(o,f,c),w(s,o,c),i(o,p,c),w(u,o,c),i(o,a,c),w(k,o,c),i(o,D,c),w(A,o,c),i(o,H,c),w(j,o,c),i(o,J,c),w(R,o,c),i(o,K,c),w(B,o,c),i(o,Q,c),w(y,o,c),i(o,V,c),w(P,o,c),i(o,Y,c),w(I,o,c),i(o,tt,c),w(z,o,c),i(o,et,c),w(q,o,c),i(o,nt,c),w(E,o,c),i(o,st,c),w(N,o,c),ot=!0},p(o,c){const ut={};c&2&&(ut.$$scope={dirty:c,ctx:o}),t.$set(ut);const mt={};c&2&&(mt.$$scope={dirty:c,ctx:o}),n.$set(mt);const pt={};c&2&&(pt.$$scope={dirty:c,ctx:o}),r.$set(pt);const lt={};c&2&&(lt.$$scope={dirty:c,ctx:o}),k.$set(lt);const it={};c&2&&(it.$$scope={dirty:c,ctx:o}),R.$set(it);const ct={};c&2&&(ct.$$scope={dirty:c,ctx:o}),I.$set(ct);const at={};c&2&&(at.$$scope={dirty:c,ctx:o}),N.$set(at)},i(o){ot||(d(t.$$.fragment,o),d(n.$$.fragment,o),d(r.$$.fragment,o),d(s.$$.fragment,o),d(u.$$.fragment,o),d(k.$$.fragment,o),d(A.$$.fragment,o),d(j.$$.fragment,o),d(R.$$.fragment,o),d(B.$$.fragment,o),d(y.$$.fragment,o),d(P.$$.fragment,o),d(I.$$.fragment,o),d(z.$$.fragment,o),d(q.$$.fragment,o),d(E.$$.fragment,o),d(N.$$.fragment,o),ot=!0)},o(o){b(t.$$.fragment,o),b(n.$$.fragment,o),b(r.$$.fragment,o),b(s.$$.fragment,o),b(u.$$.fragment,o),b(k.$$.fragment,o),b(A.$$.fragment,o),b(j.$$.fragment,o),b(R.$$.fragment,o),b(B.$$.fragment,o),b(y.$$.fragment,o),b(P.$$.fragment,o),b(I.$$.fragment,o),b(z.$$.fragment,o),b(q.$$.fragment,o),b(E.$$.fragment,o),b(N.$$.fragment,o),ot=!1},d(o){o&&(l(e),l($),l(f),l(p),l(a),l(D),l(H),l(J),l(K),l(Q),l(V),l(Y),l(tt),l(et),l(nt),l(st)),C(t,o),C(n,o),C(r,o),C(s,o),C(u,o),C(k,o),C(A,o),C(j,o),C(R,o),C(B,o),C(y,o),C(P,o),C(I,o),C(z,o),C(q,o),C(E,o),C(N,o)}}}function de(m){let t,e;const n=[m[0],wt];let $={$$slots:{default:[we]},$$scope:{ctx:m}};for(let r=0;r<n.length;r+=1)$=ft($,n[r]);return t=new kt({props:$}),{c(){_(t.$$.fragment)},l(r){g(t.$$.fragment,r)},m(r,f){w(t,r,f),e=!0},p(r,[f]){const s=f&1?xt(n,[f&1&&gt(r[0]),f&0&&gt(wt)]):{};f&2&&(s.$$scope={dirty:f,ctx:r}),t.$set(s)},i(r){e||(d(t.$$.fragment,r),e=!0)},o(r){b(t.$$.fragment,r),e=!1},d(r){C(t,r)}}}const wt={title:"bind:this",author:"henrikvilhelmberglund",authorlink:"github.com/henrikvilhelmberglund/",date:"2023-02-05T00:00:00.000Z",layout:"notes"};function be(m,t,e){return m.$$set=n=>{e(0,t=ft(ft({},t),_t(n)))},t=_t(t),[t]}class Ae extends X{constructor(t){super(),Z(this,t,be,de,W,{})}}export{Ae as default,wt as metadata};
