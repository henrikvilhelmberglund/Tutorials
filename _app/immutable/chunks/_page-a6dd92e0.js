import{S as we,i as be,s as ve,M as te,w as v,x as d,y as h,N as de,O as ie,f as D,t as S,z as C,P as _e,a as T,c as k,b as u,h as l,q as g,r as w,k as N,l as Z,m as B,G as J}from"./index-a6ce3bb5.js";import{M as he,P as I}from"./mdsvex-layout-notes-38a9c8fb.js";import De from"./Count-b23ebe4c.js";import Se from"./Double-a79f9f34.js";import Ce from"./DoubleFixed-4321f4c3.js";import Ee from"./DoubleConsole-c4516a14.js";import Oe from"./DoubleConsole2-4a2b670c.js";import{H as Te}from"./H3-514851c9.js";import{S as M}from"./Strong-98ce4a94.js";function ke(a){let t;return{c(){t=g("Let's say we have a Count component that shows a doubled value:")},l(e){t=w(e,"Let's say we have a Count component that shows a doubled value:")},m(e,o){u(e,t,o)},d(e){e&&l(t)}}}function Me(a){let t;return{c(){t=g("count * 2")},l(e){t=w(e,"count * 2")},m(e,o){u(e,t,o)},d(e){e&&l(t)}}}function Ae(a){let t;return{c(){t=g("let double = count * 2;")},l(e){t=w(e,"let double = count * 2;")},m(e,o){u(e,t,o)},d(e){e&&l(t)}}}function Ie(a){let t,e,o,f,$,m;return e=new M({props:{$$slots:{default:[Me]},$$scope:{ctx:a}}}),f=new M({props:{$$slots:{default:[Ae]},$$scope:{ctx:a}}}),{c(){t=g("This may be fine in simpler components but if we're using "),v(e.$$.fragment),o=g(" in a lot of places we might want to have a variable "),v(f.$$.fragment),$=g(" instead.")},l(s){t=w(s,"This may be fine in simpler components but if we're using "),d(e.$$.fragment,s),o=w(s," in a lot of places we might want to have a variable "),d(f.$$.fragment,s),$=w(s," instead.")},m(s,r){u(s,t,r),h(e,s,r),u(s,o,r),h(f,s,r),u(s,$,r),m=!0},p(s,r){const b={};r&2&&(b.$$scope={dirty:r,ctx:s}),e.$set(b);const p={};r&2&&(p.$$scope={dirty:r,ctx:s}),f.$set(p)},i(s){m||(D(e.$$.fragment,s),D(f.$$.fragment,s),m=!0)},o(s){S(e.$$.fragment,s),S(f.$$.fragment,s),m=!1},d(s){s&&l(t),C(e,s),s&&l(o),C(f,s),s&&l($)}}}function We(a){let t;return{c(){t=g("once when the component loads")},l(e){t=w(e,"once when the component loads")},m(e,o){u(e,t,o)},d(e){e&&l(t)}}}function He(a){let t;return{c(){t=g("reactive declaration")},l(e){t=w(e,"reactive declaration")},m(e,o){u(e,t,o)},d(e){e&&l(t)}}}function je(a){let t,e,o,f,$,m,s,r,b,p,c,E;return $=new M({props:{$$slots:{default:[We]},$$scope:{ctx:a}}}),p=new M({props:{$$slots:{default:[He]},$$scope:{ctx:a}}}),{c(){t=g("We can see we have a problem though. The variable "),e=N("code"),o=g("double"),f=g(" does not update because we're not updating it in the functions so it is only assigned to "),v($.$$.fragment),m=g(". Instead of adding a statement to update "),s=N("code"),r=g("double"),b=g(" in all of the functions we can use a "),v(p.$$.fragment),c=g(".")},l(_){t=w(_,"We can see we have a problem though. The variable "),e=Z(_,"CODE",{});var O=B(e);o=w(O,"double"),O.forEach(l),f=w(_," does not update because we're not updating it in the functions so it is only assigned to "),d($.$$.fragment,_),m=w(_,". Instead of adding a statement to update "),s=Z(_,"CODE",{});var A=B(s);r=w(A,"double"),A.forEach(l),b=w(_," in all of the functions we can use a "),d(p.$$.fragment,_),c=w(_,".")},m(_,O){u(_,t,O),u(_,e,O),J(e,o),u(_,f,O),h($,_,O),u(_,m,O),u(_,s,O),J(s,r),u(_,b,O),h(p,_,O),u(_,c,O),E=!0},p(_,O){const A={};O&2&&(A.$$scope={dirty:O,ctx:_}),$.$set(A);const L={};O&2&&(L.$$scope={dirty:O,ctx:_}),p.$set(L)},i(_){E||(D($.$$.fragment,_),D(p.$$.fragment,_),E=!0)},o(_){S($.$$.fragment,_),S(p.$$.fragment,_),E=!1},d(_){_&&l(t),_&&l(e),_&&l(f),C($,_),_&&l(m),_&&l(s),_&&l(b),C(p,_),_&&l(c)}}}function Fe(a){let t;return{c(){t=g("let double = count * 2")},l(e){t=w(e,"let double = count * 2")},m(e,o){u(e,t,o)},d(e){e&&l(t)}}}function Pe(a){let t;return{c(){t=g("$: double = count * 2")},l(e){t=w(e,"$: double = count * 2")},m(e,o){u(e,t,o)},d(e){e&&l(t)}}}function Re(a){let t,e,o,f,$,m;return e=new M({props:{$$slots:{default:[Fe]},$$scope:{ctx:a}}}),f=new M({props:{$$slots:{default:[Pe]},$$scope:{ctx:a}}}),{c(){t=g("To do that we simply replace "),v(e.$$.fragment),o=g(" with "),v(f.$$.fragment),$=g(".")},l(s){t=w(s,"To do that we simply replace "),d(e.$$.fragment,s),o=w(s," with "),d(f.$$.fragment,s),$=w(s,".")},m(s,r){u(s,t,r),h(e,s,r),u(s,o,r),h(f,s,r),u(s,$,r),m=!0},p(s,r){const b={};r&2&&(b.$$scope={dirty:r,ctx:s}),e.$set(b);const p={};r&2&&(p.$$scope={dirty:r,ctx:s}),f.$set(p)},i(s){m||(D(e.$$.fragment,s),D(f.$$.fragment,s),m=!0)},o(s){S(e.$$.fragment,s),S(f.$$.fragment,s),m=!1},d(s){s&&l(t),C(e,s),s&&l(o),C(f,s),s&&l($)}}}function qe(a){let t;return{c(){t=g("when variables to the right of = are changed, rerun this code")},l(e){t=w(e,"when variables to the right of = are changed, rerun this code")},m(e,o){u(e,t,o)},d(e){e&&l(t)}}}function Le(a){let t,e,o,f;return e=new M({props:{$$slots:{default:[qe]},$$scope:{ctx:a}}}),{c(){t=g("This is a special Svelte syntax that means "),v(e.$$.fragment),o=g(".")},l($){t=w($,"This is a special Svelte syntax that means "),d(e.$$.fragment,$),o=w($,".")},m($,m){u($,t,m),h(e,$,m),u($,o,m),f=!0},p($,m){const s={};m&2&&(s.$$scope={dirty:m,ctx:$}),e.$set(s)},i($){f||(D(e.$$.fragment,$),f=!0)},o($){S(e.$$.fragment,$),f=!1},d($){$&&l(t),C(e,$),$&&l(o)}}}function ze(a){let t;return{c(){t=g("$: double = count * 2")},l(e){t=w(e,"$: double = count * 2")},m(e,o){u(e,t,o)},d(e){e&&l(t)}}}function Ge(a){let t,e,o,f,$,m,s,r,b,p;return r=new M({props:{$$slots:{default:[ze]},$$scope:{ctx:a}}}),{c(){t=g("When we click the buttons "),e=N("code"),o=g("count"),f=g(" is changed. Since "),$=N("code"),m=g("count"),s=g(" was changed, "),v(r.$$.fragment),b=g(" will rerun so we get the correct value even though we didn't update the double value in the functions.")},l(c){t=w(c,"When we click the buttons "),e=Z(c,"CODE",{});var E=B(e);o=w(E,"count"),E.forEach(l),f=w(c," is changed. Since "),$=Z(c,"CODE",{});var _=B($);m=w(_,"count"),_.forEach(l),s=w(c," was changed, "),d(r.$$.fragment,c),b=w(c," will rerun so we get the correct value even though we didn't update the double value in the functions.")},m(c,E){u(c,t,E),u(c,e,E),J(e,o),u(c,f,E),u(c,$,E),J($,m),u(c,s,E),h(r,c,E),u(c,b,E),p=!0},p(c,E){const _={};E&2&&(_.$$scope={dirty:E,ctx:c}),r.$set(_)},i(c){p||(D(r.$$.fragment,c),p=!0)},o(c){S(r.$$.fragment,c),p=!1},d(c){c&&l(t),c&&l(e),c&&l(f),c&&l($),c&&l(s),C(r,c),c&&l(b)}}}function Ne(a){let t;return{c(){t=g("Reactive statements")},l(e){t=w(e,"Reactive statements")},m(e,o){u(e,t,o)},d(e){e&&l(t)}}}function Ze(a){let t;return{c(){t=g("reactive statements")},l(e){t=w(e,"reactive statements")},m(e,o){u(e,t,o)},d(e){e&&l(t)}}}function Be(a){let t;return{c(){t=g("$: console.log(count);")},l(e){t=w(e,"$: console.log(count);")},m(e,o){u(e,t,o)},d(e){e&&l(t)}}}function Je(a){let t,e,o,f,$,m,s,r,b;return e=new M({props:{$$slots:{default:[Ze]},$$scope:{ctx:a}}}),s=new M({props:{$$slots:{default:[Be]},$$scope:{ctx:a}}}),{c(){t=g("We can also have "),v(e.$$.fragment),o=g(". For example we can log "),f=N("code"),$=g("count"),m=g(" whenever it changes with "),v(s.$$.fragment),r=g(" which could be useful for debugging.")},l(p){t=w(p,"We can also have "),d(e.$$.fragment,p),o=w(p,". For example we can log "),f=Z(p,"CODE",{});var c=B(f);$=w(c,"count"),c.forEach(l),m=w(p," whenever it changes with "),d(s.$$.fragment,p),r=w(p," which could be useful for debugging.")},m(p,c){u(p,t,c),h(e,p,c),u(p,o,c),u(p,f,c),J(f,$),u(p,m,c),h(s,p,c),u(p,r,c),b=!0},p(p,c){const E={};c&2&&(E.$$scope={dirty:c,ctx:p}),e.$set(E);const _={};c&2&&(_.$$scope={dirty:c,ctx:p}),s.$set(_)},i(p){b||(D(e.$$.fragment,p),D(s.$$.fragment,p),b=!0)},o(p){S(e.$$.fragment,p),S(s.$$.fragment,p),b=!1},d(p){p&&l(t),C(e,p),p&&l(o),p&&l(f),p&&l(m),C(s,p),p&&l(r)}}}function Ke(a){let t;return{c(){t=g("variable it depends on (its dependency) is changed")},l(e){t=w(e,"variable it depends on (its dependency) is changed")},m(e,o){u(e,t,o)},d(e){e&&l(t)}}}function Qe(a){let t;return{c(){t=g("count")},l(e){t=w(e,"count")},m(e,o){u(e,t,o)},d(e){e&&l(t)}}}function Ue(a){let t,e,o,f,$,m;return e=new M({props:{$$slots:{default:[Ke]},$$scope:{ctx:a}}}),f=new M({props:{$$slots:{default:[Qe]},$$scope:{ctx:a}}}),{c(){t=g("As before the statement will be reevaluated whenever the "),v(e.$$.fragment),o=g(". In this case it is "),v(f.$$.fragment),$=g(" which changes when we click the buttons.")},l(s){t=w(s,"As before the statement will be reevaluated whenever the "),d(e.$$.fragment,s),o=w(s,". In this case it is "),d(f.$$.fragment,s),$=w(s," which changes when we click the buttons.")},m(s,r){u(s,t,r),h(e,s,r),u(s,o,r),h(f,s,r),u(s,$,r),m=!0},p(s,r){const b={};r&2&&(b.$$scope={dirty:r,ctx:s}),e.$set(b);const p={};r&2&&(p.$$scope={dirty:r,ctx:s}),f.$set(p)},i(s){m||(D(e.$$.fragment,s),D(f.$$.fragment,s),m=!0)},o(s){S(e.$$.fragment,s),S(f.$$.fragment,s),m=!1},d(s){s&&l(t),C(e,s),s&&l(o),C(f,s),s&&l($)}}}function Ve(a){let t;return{c(){t=g("asynchronously")},l(e){t=w(e,"asynchronously")},m(e,o){u(e,t,o)},d(e){e&&l(t)}}}function Xe(a){let t,e,o,f;return e=new M({props:{$$slots:{default:[Ve]},$$scope:{ctx:a}}}),{c(){t=g("A thing to note is that this does not happen immediately but instead "),v(e.$$.fragment),o=g(".")},l($){t=w($,"A thing to note is that this does not happen immediately but instead "),d(e.$$.fragment,$),o=w($,".")},m($,m){u($,t,m),h(e,$,m),u($,o,m),f=!0},p($,m){const s={};m&2&&(s.$$scope={dirty:m,ctx:$}),e.$set(s)},i($){f||(D(e.$$.fragment,$),f=!0)},o($){S(e.$$.fragment,$),f=!1},d($){$&&l(t),C(e,$),$&&l(o)}}}function Ye(a){let t;return{c(){t=g("just before Svelte updates the DOM")},l(e){t=w(e,"just before Svelte updates the DOM")},m(e,o){u(e,t,o)},d(e){e&&l(t)}}}function xe(a){let t,e,o,f;return e=new M({props:{$$slots:{default:[Ye]},$$scope:{ctx:a}}}),{c(){t=g("It does though happen "),v(e.$$.fragment),o=g(" (so the value in the DOM is always up to date).")},l($){t=w($,"It does though happen "),d(e.$$.fragment,$),o=w($," (so the value in the DOM is always up to date).")},m($,m){u($,t,m),h(e,$,m),u($,o,m),f=!0},p($,m){const s={};m&2&&(s.$$scope={dirty:m,ctx:$}),e.$set(s)},i($){f||(D(e.$$.fragment,$),f=!0)},o($){S(e.$$.fragment,$),f=!1},d($){$&&l(t),C(e,$),$&&l(o)}}}function ye(a){let t;return{c(){t=g("they will be automatically reordered")},l(e){t=w(e,"they will be automatically reordered")},m(e,o){u(e,t,o)},d(e){e&&l(t)}}}function et(a){let t;return{c(){t=g("top level")},l(e){t=w(e,"top level")},m(e,o){u(e,t,o)},d(e){e&&l(t)}}}function tt(a){let t,e,o,f,$,m;return e=new M({props:{$$slots:{default:[ye]},$$scope:{ctx:a}}}),f=new M({props:{$$slots:{default:[et]},$$scope:{ctx:a}}}),{c(){t=g("A final thing to note is that the order of reactive declarations doesn't matter since "),v(e.$$.fragment),o=g(" by Svelte. However they must be declared in the "),v(f.$$.fragment),$=g(" (so not in functions).")},l(s){t=w(s,"A final thing to note is that the order of reactive declarations doesn't matter since "),d(e.$$.fragment,s),o=w(s," by Svelte. However they must be declared in the "),d(f.$$.fragment,s),$=w(s," (so not in functions).")},m(s,r){u(s,t,r),h(e,s,r),u(s,o,r),h(f,s,r),u(s,$,r),m=!0},p(s,r){const b={};r&2&&(b.$$scope={dirty:r,ctx:s}),e.$set(b);const p={};r&2&&(p.$$scope={dirty:r,ctx:s}),f.$set(p)},i(s){m||(D(e.$$.fragment,s),D(f.$$.fragment,s),m=!0)},o(s){S(e.$$.fragment,s),S(f.$$.fragment,s),m=!1},d(s){s&&l(t),C(e,s),s&&l(o),C(f,s),s&&l($)}}}function nt(a){let t,e,o,f,$,m,s,r,b,p,c,E,_,O,A,L,W,K,H,Q,j,U,z,V,F,X,P,Y,G,x,R,y,q,ee;return t=new I({props:{$$slots:{default:[ke]},$$scope:{ctx:a}}}),o=new De({}),$=new I({props:{$$slots:{default:[Ie]},$$scope:{ctx:a}}}),s=new Se({}),b=new I({props:{$$slots:{default:[je]},$$scope:{ctx:a}}}),c=new I({props:{$$slots:{default:[Re]},$$scope:{ctx:a}}}),_=new Ce({}),A=new I({props:{$$slots:{default:[Le]},$$scope:{ctx:a}}}),W=new I({props:{$$slots:{default:[Ge]},$$scope:{ctx:a}}}),H=new Te({props:{$$slots:{default:[Ne]},$$scope:{ctx:a}}}),j=new I({props:{$$slots:{default:[Je]},$$scope:{ctx:a}}}),z=new Ee({}),F=new I({props:{$$slots:{default:[Ue]},$$scope:{ctx:a}}}),P=new I({props:{$$slots:{default:[Xe]},$$scope:{ctx:a}}}),G=new Oe({}),R=new I({props:{$$slots:{default:[xe]},$$scope:{ctx:a}}}),q=new I({props:{$$slots:{default:[tt]},$$scope:{ctx:a}}}),{c(){v(t.$$.fragment),e=T(),v(o.$$.fragment),f=T(),v($.$$.fragment),m=T(),v(s.$$.fragment),r=T(),v(b.$$.fragment),p=T(),v(c.$$.fragment),E=T(),v(_.$$.fragment),O=T(),v(A.$$.fragment),L=T(),v(W.$$.fragment),K=T(),v(H.$$.fragment),Q=T(),v(j.$$.fragment),U=T(),v(z.$$.fragment),V=T(),v(F.$$.fragment),X=T(),v(P.$$.fragment),Y=T(),v(G.$$.fragment),x=T(),v(R.$$.fragment),y=T(),v(q.$$.fragment)},l(n){d(t.$$.fragment,n),e=k(n),d(o.$$.fragment,n),f=k(n),d($.$$.fragment,n),m=k(n),d(s.$$.fragment,n),r=k(n),d(b.$$.fragment,n),p=k(n),d(c.$$.fragment,n),E=k(n),d(_.$$.fragment,n),O=k(n),d(A.$$.fragment,n),L=k(n),d(W.$$.fragment,n),K=k(n),d(H.$$.fragment,n),Q=k(n),d(j.$$.fragment,n),U=k(n),d(z.$$.fragment,n),V=k(n),d(F.$$.fragment,n),X=k(n),d(P.$$.fragment,n),Y=k(n),d(G.$$.fragment,n),x=k(n),d(R.$$.fragment,n),y=k(n),d(q.$$.fragment,n)},m(n,i){h(t,n,i),u(n,e,i),h(o,n,i),u(n,f,i),h($,n,i),u(n,m,i),h(s,n,i),u(n,r,i),h(b,n,i),u(n,p,i),h(c,n,i),u(n,E,i),h(_,n,i),u(n,O,i),h(A,n,i),u(n,L,i),h(W,n,i),u(n,K,i),h(H,n,i),u(n,Q,i),h(j,n,i),u(n,U,i),h(z,n,i),u(n,V,i),h(F,n,i),u(n,X,i),h(P,n,i),u(n,Y,i),h(G,n,i),u(n,x,i),h(R,n,i),u(n,y,i),h(q,n,i),ee=!0},p(n,i){const ne={};i&2&&(ne.$$scope={dirty:i,ctx:n}),t.$set(ne);const se={};i&2&&(se.$$scope={dirty:i,ctx:n}),$.$set(se);const $e={};i&2&&($e.$$scope={dirty:i,ctx:n}),b.$set($e);const oe={};i&2&&(oe.$$scope={dirty:i,ctx:n}),c.$set(oe);const fe={};i&2&&(fe.$$scope={dirty:i,ctx:n}),A.$set(fe);const le={};i&2&&(le.$$scope={dirty:i,ctx:n}),W.$set(le);const ue={};i&2&&(ue.$$scope={dirty:i,ctx:n}),H.$set(ue);const me={};i&2&&(me.$$scope={dirty:i,ctx:n}),j.$set(me);const re={};i&2&&(re.$$scope={dirty:i,ctx:n}),F.$set(re);const pe={};i&2&&(pe.$$scope={dirty:i,ctx:n}),P.$set(pe);const ae={};i&2&&(ae.$$scope={dirty:i,ctx:n}),R.$set(ae);const ce={};i&2&&(ce.$$scope={dirty:i,ctx:n}),q.$set(ce)},i(n){ee||(D(t.$$.fragment,n),D(o.$$.fragment,n),D($.$$.fragment,n),D(s.$$.fragment,n),D(b.$$.fragment,n),D(c.$$.fragment,n),D(_.$$.fragment,n),D(A.$$.fragment,n),D(W.$$.fragment,n),D(H.$$.fragment,n),D(j.$$.fragment,n),D(z.$$.fragment,n),D(F.$$.fragment,n),D(P.$$.fragment,n),D(G.$$.fragment,n),D(R.$$.fragment,n),D(q.$$.fragment,n),ee=!0)},o(n){S(t.$$.fragment,n),S(o.$$.fragment,n),S($.$$.fragment,n),S(s.$$.fragment,n),S(b.$$.fragment,n),S(c.$$.fragment,n),S(_.$$.fragment,n),S(A.$$.fragment,n),S(W.$$.fragment,n),S(H.$$.fragment,n),S(j.$$.fragment,n),S(z.$$.fragment,n),S(F.$$.fragment,n),S(P.$$.fragment,n),S(G.$$.fragment,n),S(R.$$.fragment,n),S(q.$$.fragment,n),ee=!1},d(n){C(t,n),n&&l(e),C(o,n),n&&l(f),C($,n),n&&l(m),C(s,n),n&&l(r),C(b,n),n&&l(p),C(c,n),n&&l(E),C(_,n),n&&l(O),C(A,n),n&&l(L),C(W,n),n&&l(K),C(H,n),n&&l(Q),C(j,n),n&&l(U),C(z,n),n&&l(V),C(F,n),n&&l(X),C(P,n),n&&l(Y),C(G,n),n&&l(x),C(R,n),n&&l(y),C(q,n)}}}function st(a){let t,e;const o=[a[0],ge];let f={$$slots:{default:[nt]},$$scope:{ctx:a}};for(let $=0;$<o.length;$+=1)f=te(f,o[$]);return t=new he({props:f}),{c(){v(t.$$.fragment)},l($){d(t.$$.fragment,$)},m($,m){h(t,$,m),e=!0},p($,[m]){const s=m&1?de(o,[m&1&&ie($[0]),m&0&&ie(ge)]):{};m&2&&(s.$$scope={dirty:m,ctx:$}),t.$set(s)},i($){e||(D(t.$$.fragment,$),e=!0)},o($){S(t.$$.fragment,$),e=!1},d($){C(t,$)}}}const ge={title:"Reactive declarations and statements",author:"henrikvilhelmberglund",authorlink:"github.com/henrikvilhelmberglund/",date:"2023-02-02T00:00:00.000Z",layout:"notes"};function $t(a,t,e){return a.$$set=o=>{e(0,t=te(te({},t),_e(o)))},t=_e(t),[t]}class it extends we{constructor(t){super(),be(this,t,$t,st,ve,{})}}export{it as default,ge as metadata};
